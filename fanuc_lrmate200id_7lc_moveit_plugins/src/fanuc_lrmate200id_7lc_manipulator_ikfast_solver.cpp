/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2017-05-12 13:00:14.251234
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54;
x0=IKsin(j[5]);
x1=IKsin(j[0]);
x2=IKcos(j[3]);
x3=(x1*x2);
x4=IKsin(j[3]);
x5=((1.0)*x4);
x6=IKcos(j[0]);
x7=IKsin(j[1]);
x8=IKcos(j[2]);
x9=(x7*x8);
x10=((1.0)*x9);
x11=IKsin(j[2]);
x12=IKcos(j[1]);
x13=(x11*x12);
x14=((1.0)*x13);
x15=(x14*x6);
x16=(((x5*((((x10*x6))+(((-1.0)*(1.0)*x15))))))+(((-1.0)*(1.0)*x3)));
x17=IKcos(j[5]);
x18=IKsin(j[4]);
x19=(x11*x6*x7);
x20=((1.0)*x19);
x21=(x12*x6*x8);
x22=((1.0)*x21);
x23=(x18*(((((-1.0)*(1.0)*x20))+(((-1.0)*(1.0)*x22)))));
x24=IKcos(j[4]);
x25=(x1*x4);
x26=(x6*x9);
x27=(x2*((x26+(((-1.0)*(1.0)*x15)))));
x28=(x27+x25);
x29=(x24*x28);
x30=((0.44)*x7);
x31=(x11*x12*x6);
x32=(x11*x7);
x33=((0.092)*x32);
x34=(x12*x8);
x35=((0.092)*x34);
x36=(x2*x6);
x37=(x1*x14);
x38=(((x5*((((x1*x10))+(((-1.0)*(1.0)*x37))))))+(((1.0)*x36)));
x39=(x1*x11*x7);
x40=((1.0)*x39);
x41=(x1*x12*x8);
x42=((1.0)*x41);
x43=(x18*(((((-1.0)*(1.0)*x40))+(((-1.0)*(1.0)*x42)))));
x44=(x4*x6);
x45=(x1*x9);
x46=(x2*((x45+(((-1.0)*(1.0)*x37)))));
x47=((((-1.0)*(1.0)*x44))+x46);
x48=(x24*x47);
x49=(x1*x11*x12);
x50=(x34+x32);
x51=(x4*x50);
x52=(x18*(((((-1.0)*(1.0)*x14))+x9)));
x53=(x2*x50);
x54=(x24*x53);
eerot[0]=(((x17*(((((-1.0)*(1.0)*x23))+(((-1.0)*(1.0)*x29))))))+((x0*x16)));
eerot[1]=(((x0*((x23+x29))))+((x16*x17)));
eerot[2]=(((x24*((x22+x20))))+((x18*x28)));
eetrans[0]=((((0.035055)*x26))+((x30*x6))+(((0.4184)*x19))+(((0.00325)*x3))+((x18*(((((0.092)*x25))+(((0.092)*x27))))))+((x4*(((((0.00325)*x31))+(((-1.0)*(0.00325)*x26))))))+(((-1.0)*(0.035055)*x31))+(((-1.0)*(0.0054374)*x1))+((x24*((((x33*x6))+((x35*x6))))))+(((0.4184)*x21))+(((0.05)*x6)));
eerot[3]=(((x0*x38))+((x17*(((((-1.0)*(1.0)*x48))+(((-1.0)*(1.0)*x43)))))));
eerot[4]=(((x0*((x43+x48))))+((x17*x38)));
eerot[5]=(((x18*x47))+((x24*((x40+x42)))));
eetrans[1]=(((x1*x30))+(((0.035055)*x45))+((x4*(((((-1.0)*(0.00325)*x45))+(((0.00325)*x49))))))+(((0.0054374)*x6))+((x24*((((x1*x35))+((x1*x33))))))+(((-1.0)*(0.035055)*x49))+(((0.4184)*x41))+(((0.05)*x1))+(((0.4184)*x39))+(((-1.0)*(0.00325)*x36))+((x18*(((((-1.0)*(0.092)*x44))+(((0.092)*x46)))))));
eerot[6]=(((x17*(((((-1.0)*(1.0)*x54))+(((-1.0)*(1.0)*x52))))))+((x0*x51)));
eerot[7]=(((x17*x51))+((x0*((x54+x52)))));
eerot[8]=(((x18*x53))+((x24*((x14+(((-1.0)*(1.0)*x10)))))));
eetrans[2]=((0.3291)+((x4*(((((-1.0)*(0.00325)*x34))+(((-1.0)*(0.00325)*x32))))))+(((0.44)*x12))+(((0.4184)*x13))+(((-1.0)*(0.4184)*x9))+((x24*(((((0.092)*x13))+(((-1.0)*(0.092)*x9))))))+(((0.035055)*x34))+(((0.035055)*x32))+((x18*x2*((x35+x33)))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*(((1.0)*r00)));
new_r01=((-1.0)*(((1.0)*r01)));
new_r02=r02;
new_px=((((-1.0)*(0.092)*r02))+px);
new_r10=((-1.0)*(((1.0)*r10)));
new_r11=((-1.0)*(((1.0)*r11)));
new_r12=r12;
new_py=((((-1.0)*(0.092)*r12))+py);
new_r20=((-1.0)*(((1.0)*r20)));
new_r21=((-1.0)*(((1.0)*r21)));
new_r22=r22;
new_pz=((-0.3291)+(((-1.0)*(0.092)*r22))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x55=((1.0)*py);
IkReal x56=((1.0)*pz);
IkReal x57=((1.0)*px);
pp=((pz*pz)+(py*py)+(px*px));
npx=(((pz*r20))+((py*r10))+((px*r00)));
npy=(((pz*r21))+((py*r11))+((px*r01)));
npz=(((px*r02))+((pz*r22))+((py*r12)));
rxp0_0=((((-1.0)*r20*x55))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x56)));
rxp0_2=(((py*r00))+(((-1.0)*r10*x57)));
rxp1_0=((((-1.0)*r21*x55))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x56)));
rxp1_2=((((-1.0)*r11*x57))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x55)));
rxp2_1=((((-1.0)*r02*x56))+((px*r22)));
rxp2_2=((((-1.0)*r12*x57))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x58=((0.00325)*r20);
IkReal x59=((-1.0)*x58);
IkReal x60=((0.0054374)*r02);
IkReal x61=((-1.0)*(((1.0)*rxp2_2)));
IkReal x62=(x61+x60);
IkReal x63=((0.0054374)*r12);
IkReal x64=((0.0065)*r21);
IkReal x65=((-1.0)*x60);
IkReal x66=(x61+x65);
IkReal x67=((0.0065)*npy);
IkReal x68=((0.8368)*npz);
IkReal x69=((-1.0)*(((1.0)*pp)));
IkReal x70=((0.0035055)*r22);
IkReal x71=((0.01483158979376)+x68+x69+x67+x70);
IkReal x72=((0.1)*px);
IkReal x73=((0.000325)*r01);
IkReal x74=((-1.0)*x73);
IkReal x75=((0.04184)*r02);
IkReal x76=((-1.0)*x75);
IkReal x77=((0.0002278575)*r10);
IkReal x78=((-1.0)*x77);
IkReal x79=((0.07011)*rxp2_1);
IkReal x80=((-1.0)*x79);
IkReal x81=((0.000381216114)*r22);
IkReal x82=((-1.0)*x81);
IkReal x83=((0.00054374)+x82);
IkReal x84=((0.1)*py);
IkReal x85=((0.0002278575)*r00);
IkReal x86=((0.000325)*r11);
IkReal x87=((-1.0)*x86);
IkReal x88=((0.04184)*r12);
IkReal x89=((-1.0)*x88);
IkReal x90=((0.07011)*rxp2_0);
IkReal x91=(x90+x85+x87+x84+x89);
IkReal x92=((0.000455715)*r11);
IkReal x93=((0.013)*npx);
IkReal x94=((0.00065)*r00);
IkReal x95=((((-1.0)*x94))+x93);
IkReal x96=((0.000455715)*r01);
IkReal x97=((-1.0)*(((0.00065)*r10)));
IkReal x98=(x97+(((-1.0)*x96)));
IkReal x99=((-1.0)*x67);
IkReal x100=((0.01483158979376)+x68+x69+x99+x70);
IkReal x101=((-1.0)*x85);
IkReal x102=(x101+x90+x86+x84+x89);
IkReal x103=((-0.00054374)+x81);
IkReal x104=((-1.0)*x72);
IkReal x105=((-1.0)*x92);
IkReal x106=(x93+x94);
IkReal x107=((2.0)*rxp0_2);
IkReal x108=((0.0108748)*r00);
IkReal x109=((-1.0)*(((0.0065)*r22)));
IkReal x110=(x109+(((-1.0)*x108)));
IkReal x111=((0.0108748)*r10);
IkReal x112=((-1.0)*x111);
IkReal x113=((0.0217496)*r01);
IkReal x114=((-1.0)*(((4.0)*rxp1_2)));
IkReal x115=((0.0217496)*r11);
IkReal x116=((-1.0)*x107);
IkReal x117=(x109+x108);
IkReal x118=((0.08368)*r00);
IkReal x119=((0.14022)*rxp0_1);
IkReal x120=((1.6736)*npx);
IkReal x121=((-1.0)*x120);
IkReal x122=((0.000455715)*r12);
IkReal x123=((-1.0)*x122);
IkReal x124=((0.007011)*r20);
IkReal x125=((-1.0)*x124);
IkReal x126=((0.000762432228)*r20);
IkReal x127=((0.000455715)*r02);
IkReal x128=((0.08368)*r10);
IkReal x129=((0.14022)*rxp0_0);
IkReal x130=(x128+x127+(((-1.0)*x129)));
IkReal x131=((((0.014022)*r21))+(((3.3472)*npy)));
IkReal x132=((0.16736)*r01);
IkReal x133=((0.28044)*rxp1_1);
IkReal x134=((0.001524864456)*r21);
IkReal x135=((((0.28044)*rxp1_0))+(((-1.0)*(0.16736)*r11)));
IkReal x136=(x124+x120);
IkReal x137=((-1.0)*x118);
IkReal x138=((-1.0)*x119);
IkReal x139=((-1.0)*x126);
IkReal x140=((((-1.0)*x128))+x129+x127);
IkReal x141=(x65+rxp2_2);
IkReal x142=((-1.0)*x63);
IkReal x143=((-1.0)*x64);
IkReal x144=(x60+rxp2_2);
IkReal x145=((-1.0)*x68);
IkReal x146=((-1.0)*x70);
IkReal x147=((0.00054374)+x81);
IkReal x148=((-1.0)*x90);
IkReal x149=(x101+x148+x87+x84+x88);
IkReal x150=(x96+x97);
IkReal x151=(x148+x86+x85+x84+x88);
IkReal x152=((-0.00054374)+x82);
op[0]=(x62+x59);
op[1]=x63;
op[2]=x64;
op[3]=0;
op[4]=(x62+x58);
op[5]=x63;
op[6]=x63;
op[7]=(x66+x59);
op[8]=0;
op[9]=x64;
op[10]=x63;
op[11]=(x66+x58);
op[12]=(x80+x71+x72+x74+x76+x78);
op[13]=(x91+x83);
op[14]=(x92+x95);
op[15]=x98;
op[16]=(x100+x80+x73+x72+x77+x76);
op[17]=(x102+x83);
op[18]=(x103+x91);
op[19]=(x104+x71+x73+x75+x77+x79);
op[20]=x98;
op[21]=(x105+x106);
op[22]=(x102+x103);
op[23]=(x104+x100+x75+x74+x79+x78);
op[24]=(x107+x110);
op[25]=x112;
op[26]=(x114+x113);
op[27]=x115;
op[28]=(x117+x116);
op[29]=x111;
op[30]=x112;
op[31]=(x107+x117);
op[32]=x115;
op[33]=((((-1.0)*x113))+x114);
op[34]=x111;
op[35]=(x116+x110);
op[36]=(x125+x121+x123+x119+x118);
op[37]=(x130+x126);
op[38]=(x131+(((-1.0)*x133))+(((-1.0)*x132)));
op[39]=(x135+(((-1.0)*x134)));
op[40]=(x138+x137+x136+x123);
op[41]=(x139+x140);
op[42]=(x139+x130);
op[43]=(x138+x137+x125+x121+x122);
op[44]=(x135+x134);
op[45]=(x133+x131+x132);
op[46]=(x126+x140);
op[47]=(x136+x122+x119+x118);
op[48]=(x141+x58);
op[49]=x142;
op[50]=x143;
op[51]=0;
op[52]=(x141+x59);
op[53]=x142;
op[54]=x142;
op[55]=(x144+x58);
op[56]=0;
op[57]=x143;
op[58]=x142;
op[59]=(x144+x59);
op[60]=((0.01483158979376)+x145+x146+x69+x67+x72+x75+x74+x77+x79);
op[61]=(x149+x147);
op[62]=(x105+x95);
op[63]=x150;
op[64]=((0.01483158979376)+x145+x146+x69+x99+x73+x72+x75+x79+x78);
op[65]=(x151+x147);
op[66]=(x152+x149);
op[67]=((0.01483158979376)+x104+x145+x146+x69+x67+x80+x73+x76+x78);
op[68]=x150;
op[69]=(x106+x92);
op[70]=(x152+x151);
op[71]=((0.01483158979376)+x104+x145+x146+x69+x99+x80+x74+x77+x76);
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x153=htj4*htj4;
CheckValue<IkReal> x154=IKPowWithIntegerCheck(((1.0)+x153),-1);
if(!x154.valid){
continue;
}
cj4array[numsolutions]=((x154.value)*(((1.0)+(((-1.0)*x153)))));
CheckValue<IkReal> x155=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x155.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x155.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x156=htj5*htj5;
CheckValue<IkReal> x157=IKPowWithIntegerCheck(((1.0)+x156),-1);
if(!x157.valid){
continue;
}
cj5array[numsolutions]=((x157.value)*(((1.0)+(((-1.0)*x156)))));
CheckValue<IkReal> x158=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x158.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x158.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x159=htj0*htj0;
CheckValue<IkReal> x160=IKPowWithIntegerCheck(((1.0)+x159),-1);
if(!x160.valid){
continue;
}
cj0array[numsolutions]=((x160.value)*(((1.0)+(((-1.0)*x159)))));
CheckValue<IkReal> x161=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x161.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x161.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[3];
IkReal x162=((1.0)*sj4);
IkReal x163=((((-1.0)*cj4*r12))+((cj5*r10*sj4))+(((-1.0)*r11*sj5*x162)));
IkReal x164=(r21*sj0);
IkReal x165=(r20*sj0);
j3eval[0]=x163;
j3eval[1]=IKsign(x163);
j3eval[2]=((IKabs((((cj4*sj5*x164))+(((-1.0)*r22*sj0*x162))+(((-1.0)*cj4*cj5*x165)))))+(IKabs((((sj5*x165))+((cj5*x164))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
IkReal x166=(((r01*sj4*sj5))+((cj4*r02))+(((-1.0)*(1.0)*cj5*r00*sj4)));
IkReal x167=(cj0*cj5);
IkReal x168=(cj0*sj5);
j3eval[0]=x166;
j3eval[1]=((IKabs((((r21*x167))+((r20*x168)))))+(IKabs((((cj4*r20*x167))+(((-1.0)*cj4*r21*x168))+((cj0*r22*sj4))))));
j3eval[2]=IKsign(x166);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x169=((((-1.0)*(1.0)*cj4*r22))+((cj5*r20*sj4))+(((-1.0)*(1.0)*r21*sj4*sj5)));
j3eval[0]=x169;
j3eval[1]=IKsign(x169);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x170=((1.0)*sj4);
IkReal x171=((((-1.0)*cj5*r20*x170))+((r21*sj4*sj5))+((cj4*r22)));
j3eval[0]=x171;
j3eval[1]=IKsign(x171);
j3eval[2]=((IKabs((((r10*sj5))+((cj5*r11)))))+(IKabs((((cj4*r11*sj5))+(((-1.0)*(1.0)*cj4*cj5*r10))+(((-1.0)*r12*x170))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x172=((1.0)*cj4);
IkReal x173=((1.0)*sj4);
IkReal x174=(((cj5*r10*sj4))+(((-1.0)*r12*x172))+(((-1.0)*r11*sj5*x173)));
j3eval[0]=x174;
j3eval[1]=((IKabs((((r20*sj5))+((cj5*r21)))))+(IKabs(((((-1.0)*r22*x173))+((cj4*r21*sj5))+(((-1.0)*cj5*r20*x172))))));
j3eval[2]=IKsign(x174);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x175=r00*r00;
IkReal x176=r02*r02;
IkReal x177=(r00*sj5);
IkReal x178=((2.0)*cj5*r01*x177);
IkReal x179=cj4*cj4;
IkReal x180=r01*r01;
IkReal x181=(x179*x180);
IkReal x182=cj5*cj5;
IkReal x183=((2.0)*r02*sj4);
IkReal x184=(cj4*cj5*r00);
IkReal x185=(cj4*r01*sj5);
IkReal x186=(x175*x182);
IkReal x187=((((-1.0)*x176*x179))+(((-1.0)*x181*x182))+((x183*x184))+((x180*x182))+(((-1.0)*x183*x185))+x178+x176+x175+((x179*x186))+(((-1.0)*x178*x179))+(((-1.0)*x186))+x181);
j3eval[0]=x187;
j3eval[1]=((IKabs((((cj5*r01))+x177)))+(IKabs((((r02*sj4))+(((-1.0)*x185))+x184))));
j3eval[2]=IKsign(x187);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x188=(cj4*cj5*r00);
IkReal x189=(cj4*r01*sj5);
IkReal x190=(r00*sj5);
IkReal x191=r00*r00;
IkReal x192=r02*r02;
IkReal x193=((2.0)*cj5*r01*x190);
IkReal x194=cj4*cj4;
IkReal x195=r01*r01;
IkReal x196=(x194*x195);
IkReal x197=cj5*cj5;
IkReal x198=((2.0)*r02*sj4);
IkReal x199=(x191*x197);
CheckValue<IkReal> x200=IKPowWithIntegerCheck(IKsign((((x188*x198))+(((-1.0)*x199))+(((-1.0)*x193*x194))+((x194*x199))+((x195*x197))+(((-1.0)*x192*x194))+(((-1.0)*x189*x198))+x192+x191+x193+x196+(((-1.0)*x196*x197)))),-1);
if(!x200.valid){
continue;
}
CheckValue<IkReal> x201 = IKatan2WithCheck(IkReal(((((-1.0)*x189))+((r02*sj4))+x188)),IkReal((((cj5*r01))+x190)),IKFAST_ATAN2_MAGTHRESH);
if(!x201.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x200.value)))+(x201.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x202=IKsin(j3);
IkReal x203=(cj5*r01);
IkReal x204=(r00*sj5);
IkReal x205=(r02*sj4);
IkReal x206=IKcos(j3);
IkReal x207=((1.0)*x206);
IkReal x208=(cj4*r01*sj5);
IkReal x209=(cj4*r00);
IkReal x210=((1.0)*cj5*x206);
IkReal x211=((1.0)*sj5*x206);
IkReal x212=((1.0)*sj4*x202);
IkReal x213=(cj4*sj5*x202);
IkReal x214=((1.0)*cj4*cj5*x202);
evalcond[0]=(((x206*x208))+(((-1.0)*x205*x207))+(((-1.0)*x209*x210))+((x202*x203))+((x202*x204)));
evalcond[1]=((((-1.0)*r20*x214))+(((-1.0)*r22*x212))+(((-1.0)*r20*x211))+((r21*x213))+(((-1.0)*r21*x210)));
evalcond[2]=((((-1.0)*r12*x212))+((r11*x213))+(((-1.0)*r10*x211))+(((-1.0)*r11*x210))+(((-1.0)*r10*x214)));
evalcond[3]=((1.0)+(((-1.0)*cj5*x202*x209))+(((-1.0)*x203*x207))+(((-1.0)*x204*x207))+((x202*x208))+(((-1.0)*x202*x205)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x215=(cj4*r12);
IkReal x216=(cj5*r11);
IkReal x217=(cj5*r21);
IkReal x218=(r10*sj5);
IkReal x219=(r20*sj5);
IkReal x220=(cj5*r10*sj4);
IkReal x221=(r11*sj4*sj5);
IkReal x222=((((-1.0)*(0.42066)*pz))+(((0.0163176)*x218))+(((0.0163176)*x216))+(((-2.1154489563)*x220))+(((-1.0)*(5.0208)*py))+(((0.001367145)*x217))+(((2.1154489563)*x221))+(((2.1154489563)*x215))+(((0.001367145)*x219)));
IkReal x223=(cj4*r22);
IkReal x224=(cj5*r20*sj4);
IkReal x225=(r21*sj4*sj5);
IkReal x226=((((5.0208)*x225))+(((0.039)*x219))+(((0.039)*x217))+(((-0.42066)*x220))+(((-1.0)*(12.0)*pz))+(((0.42066)*x221))+(((0.42066)*x215))+(((-5.0208)*x224))+(((5.0208)*x223)));
j1eval[0]=((5.891072)+(IKabs(((-1.76)+x226)))+(IKabs(((1.76)+x226)))+(IKabs(((-1.76)+(((-0.14022)*x220))+(((-1.6736)*x224))+(((0.013)*x219))+(((1.6736)*x223))+(((-1.0)*(4.0)*pz))+(((1.6736)*x225))+(((0.14022)*x221))+(((0.14022)*x215))+(((0.013)*x217)))))+(IKabs(((0.0219832)+(((0.7051496521)*x215))+(((0.0054392)*x218))+(((0.000455715)*x219))+(((-1.0)*(0.14022)*pz))+(((-0.7051496521)*x220))+(((0.7051496521)*x221))+(((0.000455715)*x217))+(((-1.0)*(1.6736)*py))+(((0.0054392)*x216)))))+(IKabs(((0.1893432)+x222)))+(IKabs(((0.3127368)+x222))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x227=(cj4*r12);
IkReal x228=(cj4*r22);
IkReal x229=(cj5*r21);
IkReal x230=(r20*sj5);
IkReal x231=(cj5*r10*sj4);
IkReal x232=(cj5*r20*sj4);
IkReal x233=(r11*sj4*sj5);
IkReal x234=(r21*sj4*sj5);
IkReal x235=((((0.013)*x229))+(((0.14022)*x227))+(((0.14022)*x233))+(((-1.0)*(4.0)*pz))+(((1.6736)*x228))+(((-0.14022)*x231))+(((-1.6736)*x232))+(((1.6736)*x234))+(((0.013)*x230)));
IkReal x236=((((0.42066)*x227))+(((-1.0)*(12.0)*pz))+(((5.0208)*x228))+(((0.039)*x230))+(((0.42066)*x233))+(((5.0208)*x234))+(((0.039)*x229))+(((-0.42066)*x231))+(((-5.0208)*x232)));
op[0]=((-1.76)+x235);
op[1]=0;
op[2]=((-1.76)+x236);
op[3]=0;
op[4]=((1.76)+x236);
op[5]=0;
op[6]=((1.76)+x235);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x237=(cj4*r12);
IkReal x238=(cj5*r11);
IkReal x239=(cj5*r21);
IkReal x240=(r10*sj5);
IkReal x241=(r20*sj5);
IkReal x242=(cj5*r10*sj4);
IkReal x243=(r11*sj4*sj5);
IkReal x244=((((0.0054392)*x238))+(((-1.0)*(0.14022)*pz))+(((0.000455715)*x241))+(((0.0054392)*x240))+(((0.7051496521)*x243))+(((0.7051496521)*x237))+(((0.000455715)*x239))+(((-0.7051496521)*x242))+(((-1.0)*(1.6736)*py)));
IkReal x245=((((-1.0)*(0.42066)*pz))+(((0.0163176)*x240))+(((2.1154489563)*x237))+(((-1.0)*(5.0208)*py))+(((2.1154489563)*x243))+(((0.001367145)*x239))+(((0.001367145)*x241))+(((0.0163176)*x238))+(((-2.1154489563)*x242)));
j1evalpoly[0]=((0.1453768)+(((2.945536)*(htj1*htj1*htj1)))+x244+(((1.472768)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.0219832)+x244))))+(((htj1*htj1)*(((0.3127368)+x245))))+(((htj1*htj1*htj1*htj1)*(((0.1893432)+x245))))+(((1.472768)*htj1)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x246=(cj1*cj4);
IkReal x247=(cj4*sj1);
IkReal x248=(cj1*sj4*sj5);
IkReal x249=(sj1*sj4*sj5);
IkReal x250=(cj5*r20);
IkReal x251=((1.0)*cj1*sj4);
IkReal x252=(cj5*r10);
if( IKabs((((r11*x249))+((r21*x248))+((r12*x247))+((r22*x246))+(((-1.0)*sj1*sj4*x252))+(((-1.0)*x250*x251)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r21*x249))+((sj1*sj4*x250))+((r12*x246))+(((-1.0)*x251*x252))+((r11*x248))+(((-1.0)*r22*x247)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r11*x249))+((r21*x248))+((r12*x247))+((r22*x246))+(((-1.0)*sj1*sj4*x252))+(((-1.0)*x250*x251))))+IKsqr(((((-1.0)*r21*x249))+((sj1*sj4*x250))+((r12*x246))+(((-1.0)*x251*x252))+((r11*x248))+(((-1.0)*r22*x247))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r11*x249))+((r21*x248))+((r12*x247))+((r22*x246))+(((-1.0)*sj1*sj4*x252))+(((-1.0)*x250*x251))), ((((-1.0)*r21*x249))+((sj1*sj4*x250))+((r12*x246))+(((-1.0)*x251*x252))+((r11*x248))+(((-1.0)*r22*x247))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x253=IKcos(j2);
IkReal x254=(cj1*x253);
IkReal x255=IKsin(j2);
IkReal x256=(sj1*x255);
IkReal x257=(x256+x254);
IkReal x258=((1.0)*cj4);
IkReal x259=(cj5*sj4);
IkReal x260=((1.0)*sj4*sj5);
IkReal x261=(cj1*x255);
IkReal x262=(sj1*x253);
IkReal x263=(cj5*sj3);
IkReal x264=(sj3*sj5);
IkReal x265=((1.0)*cj3*sj4);
IkReal x266=(cj3*cj4*sj5);
IkReal x267=((1.0)*cj3*cj4*cj5);
IkReal x268=((0.00325)*cj5);
IkReal x269=((0.00325)*sj5);
evalcond[0]=(x257+(((-1.0)*r11*x260))+((r10*x259))+(((-1.0)*r12*x258)));
evalcond[1]=(((r20*x259))+x261+(((-1.0)*r21*x260))+(((-1.0)*r22*x258))+(((-1.0)*x262)));
evalcond[2]=(((r21*x266))+(((-1.0)*r22*x265))+((r20*x264))+((r21*x263))+x257+(((-1.0)*r20*x267)));
evalcond[3]=(((r11*x263))+(((-1.0)*r12*x265))+x262+((r11*x266))+(((-1.0)*r10*x267))+((r10*x264))+(((-1.0)*x261)));
evalcond[4]=((((-1.0)*(1.0)*pz))+(((-0.4184)*x262))+(((0.44)*cj1))+(((0.4184)*x261))+(((0.035055)*x256))+((r21*x268))+((r20*x269))+(((0.035055)*x254)));
evalcond[5]=((0.05)+((r10*x269))+(((-1.0)*(1.0)*py))+(((0.035055)*x262))+(((0.44)*sj1))+(((-0.035055)*x261))+((r11*x268))+(((0.4184)*x256))+(((0.4184)*x254)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x270=((1.0)*cj4);
IkReal x271=((1.0)*sj4);
CheckValue<IkReal> x272=IKPowWithIntegerCheck(IKsign(((((-1.0)*r12*x270))+((cj5*r10*sj4))+(((-1.0)*r11*sj5*x271)))),-1);
if(!x272.valid){
continue;
}
CheckValue<IkReal> x273 = IKatan2WithCheck(IkReal((((r20*sj5))+((cj5*r21)))),IkReal(((((-1.0)*cj5*r20*x270))+((cj4*r21*sj5))+(((-1.0)*r22*x271)))),IKFAST_ATAN2_MAGTHRESH);
if(!x273.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x272.value)))+(x273.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x274=IKsin(j3);
IkReal x275=(cj5*r01);
IkReal x276=(r00*sj5);
IkReal x277=(r02*sj4);
IkReal x278=IKcos(j3);
IkReal x279=((1.0)*x278);
IkReal x280=(cj4*r01*sj5);
IkReal x281=(cj4*r00);
IkReal x282=((1.0)*cj5*x278);
IkReal x283=((1.0)*sj5*x278);
IkReal x284=((1.0)*sj4*x274);
IkReal x285=(cj4*sj5*x274);
IkReal x286=((1.0)*cj4*cj5*x274);
evalcond[0]=(((x274*x275))+((x274*x276))+((x278*x280))+(((-1.0)*x277*x279))+(((-1.0)*x281*x282)));
evalcond[1]=((((-1.0)*r20*x283))+(((-1.0)*r20*x286))+(((-1.0)*r22*x284))+((r21*x285))+(((-1.0)*r21*x282)));
evalcond[2]=((((-1.0)*r10*x286))+((r11*x285))+(((-1.0)*r10*x283))+(((-1.0)*r11*x282))+(((-1.0)*r12*x284)));
evalcond[3]=((1.0)+(((-1.0)*x274*x277))+(((-1.0)*x276*x279))+(((-1.0)*cj5*x274*x281))+(((-1.0)*x275*x279))+((x274*x280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x287=(cj4*r12);
IkReal x288=(cj5*r11);
IkReal x289=(cj5*r21);
IkReal x290=(r10*sj5);
IkReal x291=(r20*sj5);
IkReal x292=(cj5*r10*sj4);
IkReal x293=(r11*sj4*sj5);
IkReal x294=((((-1.0)*(0.42066)*pz))+(((-1.0)*(5.0208)*py))+(((2.1154489563)*x287))+(((0.001367145)*x291))+(((0.001367145)*x289))+(((0.0163176)*x288))+(((0.0163176)*x290))+(((2.1154489563)*x293))+(((-2.1154489563)*x292)));
IkReal x295=(cj4*r22);
IkReal x296=(cj5*r20*sj4);
IkReal x297=(r21*sj4*sj5);
IkReal x298=((((-1.0)*(12.0)*pz))+(((0.039)*x291))+(((0.42066)*x287))+(((0.039)*x289))+(((-0.42066)*x292))+(((0.42066)*x293))+(((5.0208)*x295))+(((5.0208)*x297))+(((-5.0208)*x296)));
j1eval[0]=((5.891072)+(IKabs(((0.3127368)+x294)))+(IKabs(((-1.76)+(((0.013)*x291))+(((-1.0)*(4.0)*pz))+(((0.013)*x289))+(((0.14022)*x293))+(((-0.14022)*x292))+(((-1.6736)*x296))+(((1.6736)*x297))+(((0.14022)*x287))+(((1.6736)*x295)))))+(IKabs(((0.1893432)+x294)))+(IKabs(((1.76)+x298)))+(IKabs(((-1.76)+x298)))+(IKabs(((0.0219832)+(((-1.0)*(0.14022)*pz))+(((-0.7051496521)*x292))+(((0.0054392)*x288))+(((0.7051496521)*x293))+(((0.0054392)*x290))+(((0.000455715)*x289))+(((-1.0)*(1.6736)*py))+(((0.7051496521)*x287))+(((0.000455715)*x291))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x299=(cj4*r12);
IkReal x300=(cj4*r22);
IkReal x301=(cj5*r21);
IkReal x302=(r20*sj5);
IkReal x303=(cj5*r10*sj4);
IkReal x304=(cj5*r20*sj4);
IkReal x305=(r11*sj4*sj5);
IkReal x306=(r21*sj4*sj5);
IkReal x307=((((0.013)*x301))+(((1.6736)*x306))+(((-1.0)*(4.0)*pz))+(((0.14022)*x299))+(((1.6736)*x300))+(((-1.6736)*x304))+(((-0.14022)*x303))+(((0.013)*x302))+(((0.14022)*x305)));
IkReal x308=((((5.0208)*x300))+(((-1.0)*(12.0)*pz))+(((0.039)*x301))+(((0.039)*x302))+(((-0.42066)*x303))+(((0.42066)*x299))+(((5.0208)*x306))+(((0.42066)*x305))+(((-5.0208)*x304)));
op[0]=((-1.76)+x307);
op[1]=0;
op[2]=((-1.76)+x308);
op[3]=0;
op[4]=((1.76)+x308);
op[5]=0;
op[6]=((1.76)+x307);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x309=(cj4*r12);
IkReal x310=(cj5*r11);
IkReal x311=(cj5*r21);
IkReal x312=(r10*sj5);
IkReal x313=(r20*sj5);
IkReal x314=(cj5*r10*sj4);
IkReal x315=(r11*sj4*sj5);
IkReal x316=((((0.7051496521)*x315))+(((-1.0)*(0.14022)*pz))+(((0.000455715)*x313))+(((-0.7051496521)*x314))+(((0.0054392)*x310))+(((0.000455715)*x311))+(((0.0054392)*x312))+(((0.7051496521)*x309))+(((-1.0)*(1.6736)*py)));
IkReal x317=((((-1.0)*(0.42066)*pz))+(((-1.0)*(5.0208)*py))+(((-2.1154489563)*x314))+(((0.0163176)*x310))+(((2.1154489563)*x309))+(((0.001367145)*x311))+(((0.0163176)*x312))+(((2.1154489563)*x315))+(((0.001367145)*x313)));
j1evalpoly[0]=((0.1453768)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.0219832)+x316))))+(((htj1*htj1)*(((0.3127368)+x317))))+(((2.945536)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.1893432)+x317))))+(((1.472768)*(htj1*htj1*htj1*htj1*htj1)))+x316+(((1.472768)*htj1)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x318=(cj1*cj4);
IkReal x319=(cj4*sj1);
IkReal x320=(cj1*sj4*sj5);
IkReal x321=(sj1*sj4*sj5);
IkReal x322=(cj5*r20);
IkReal x323=((1.0)*cj1*sj4);
IkReal x324=(cj5*r10);
if( IKabs((((r12*x319))+(((-1.0)*sj1*sj4*x324))+((r21*x320))+((r11*x321))+(((-1.0)*x322*x323))+((r22*x318)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r21*x321))+((r12*x318))+(((-1.0)*x323*x324))+((r11*x320))+((sj1*sj4*x322))+(((-1.0)*r22*x319)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r12*x319))+(((-1.0)*sj1*sj4*x324))+((r21*x320))+((r11*x321))+(((-1.0)*x322*x323))+((r22*x318))))+IKsqr(((((-1.0)*r21*x321))+((r12*x318))+(((-1.0)*x323*x324))+((r11*x320))+((sj1*sj4*x322))+(((-1.0)*r22*x319))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r12*x319))+(((-1.0)*sj1*sj4*x324))+((r21*x320))+((r11*x321))+(((-1.0)*x322*x323))+((r22*x318))), ((((-1.0)*r21*x321))+((r12*x318))+(((-1.0)*x323*x324))+((r11*x320))+((sj1*sj4*x322))+(((-1.0)*r22*x319))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x325=IKcos(j2);
IkReal x326=(cj1*x325);
IkReal x327=IKsin(j2);
IkReal x328=(sj1*x327);
IkReal x329=(x328+x326);
IkReal x330=((1.0)*cj4);
IkReal x331=(cj5*sj4);
IkReal x332=((1.0)*sj4*sj5);
IkReal x333=(cj1*x327);
IkReal x334=(sj1*x325);
IkReal x335=(cj5*sj3);
IkReal x336=(sj3*sj5);
IkReal x337=((1.0)*cj3*sj4);
IkReal x338=(cj3*cj4*sj5);
IkReal x339=((1.0)*cj3*cj4*cj5);
IkReal x340=((0.00325)*cj5);
IkReal x341=((0.00325)*sj5);
evalcond[0]=((((-1.0)*r11*x332))+x329+(((-1.0)*r12*x330))+((r10*x331)));
evalcond[1]=(((r20*x331))+(((-1.0)*r21*x332))+x333+(((-1.0)*x334))+(((-1.0)*r22*x330)));
evalcond[2]=(((r21*x338))+(((-1.0)*r22*x337))+((r20*x336))+x329+((r21*x335))+(((-1.0)*r20*x339)));
evalcond[3]=(((r11*x338))+((r10*x336))+x334+(((-1.0)*x333))+(((-1.0)*r10*x339))+(((-1.0)*r12*x337))+((r11*x335)));
evalcond[4]=((((0.035055)*x328))+(((0.035055)*x326))+(((-1.0)*(1.0)*pz))+((r20*x341))+(((0.4184)*x333))+(((-0.4184)*x334))+((r21*x340))+(((0.44)*cj1)));
evalcond[5]=((0.05)+(((0.035055)*x334))+(((-1.0)*(1.0)*py))+((r10*x341))+(((0.44)*sj1))+(((0.4184)*x328))+(((-0.035055)*x333))+(((0.4184)*x326))+((r11*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x342=((1.0)*sj4);
CheckValue<IkReal> x343 = IKatan2WithCheck(IkReal((((r10*sj5))+((cj5*r11)))),IkReal((((cj4*r11*sj5))+(((-1.0)*(1.0)*cj4*cj5*r10))+(((-1.0)*r12*x342)))),IKFAST_ATAN2_MAGTHRESH);
if(!x343.valid){
continue;
}
CheckValue<IkReal> x344=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj5*r20*x342))+((r21*sj4*sj5))+((cj4*r22)))),-1);
if(!x344.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x343.value)+(((1.5707963267949)*(x344.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x345=IKsin(j3);
IkReal x346=(cj5*r01);
IkReal x347=(r00*sj5);
IkReal x348=(r02*sj4);
IkReal x349=IKcos(j3);
IkReal x350=((1.0)*x349);
IkReal x351=(cj4*r01*sj5);
IkReal x352=(cj4*r00);
IkReal x353=((1.0)*cj5*x349);
IkReal x354=((1.0)*sj5*x349);
IkReal x355=((1.0)*sj4*x345);
IkReal x356=(cj4*sj5*x345);
IkReal x357=((1.0)*cj4*cj5*x345);
evalcond[0]=((((-1.0)*x348*x350))+(((-1.0)*x352*x353))+((x345*x347))+((x345*x346))+((x349*x351)));
evalcond[1]=((((-1.0)*r22*x355))+(((-1.0)*r20*x357))+(((-1.0)*r20*x354))+((r21*x356))+(((-1.0)*r21*x353)));
evalcond[2]=(((r11*x356))+(((-1.0)*r11*x353))+(((-1.0)*r12*x355))+(((-1.0)*r10*x354))+(((-1.0)*r10*x357)));
evalcond[3]=((1.0)+((x345*x351))+(((-1.0)*x346*x350))+(((-1.0)*x345*x348))+(((-1.0)*cj5*x345*x352))+(((-1.0)*x347*x350)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x358=(cj4*r12);
IkReal x359=(cj5*r11);
IkReal x360=(cj5*r21);
IkReal x361=(r10*sj5);
IkReal x362=(r20*sj5);
IkReal x363=(cj5*r10*sj4);
IkReal x364=(r11*sj4*sj5);
IkReal x365=((((-1.0)*(0.42066)*pz))+(((-1.0)*(5.0208)*py))+(((0.0163176)*x361))+(((2.1154489563)*x358))+(((0.001367145)*x360))+(((0.001367145)*x362))+(((-2.1154489563)*x363))+(((2.1154489563)*x364))+(((0.0163176)*x359)));
IkReal x366=(cj4*r22);
IkReal x367=(cj5*r20*sj4);
IkReal x368=(r21*sj4*sj5);
IkReal x369=((((0.039)*x360))+(((-1.0)*(12.0)*pz))+(((0.42066)*x358))+(((0.039)*x362))+(((5.0208)*x368))+(((0.42066)*x364))+(((-5.0208)*x367))+(((-0.42066)*x363))+(((5.0208)*x366)));
j1eval[0]=((5.891072)+(IKabs(((0.0219832)+(((0.000455715)*x362))+(((-0.7051496521)*x363))+(((0.000455715)*x360))+(((-1.0)*(0.14022)*pz))+(((0.7051496521)*x358))+(((0.7051496521)*x364))+(((0.0054392)*x359))+(((-1.0)*(1.6736)*py))+(((0.0054392)*x361)))))+(IKabs(((0.1893432)+x365)))+(IKabs(((-1.76)+x369)))+(IKabs(((0.3127368)+x365)))+(IKabs(((1.76)+x369)))+(IKabs(((-1.76)+(((1.6736)*x366))+(((-1.0)*(4.0)*pz))+(((1.6736)*x368))+(((0.14022)*x358))+(((0.013)*x362))+(((0.013)*x360))+(((-0.14022)*x363))+(((0.14022)*x364))+(((-1.6736)*x367))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x370=(cj4*r12);
IkReal x371=(cj4*r22);
IkReal x372=(cj5*r21);
IkReal x373=(r20*sj5);
IkReal x374=(cj5*r10*sj4);
IkReal x375=(cj5*r20*sj4);
IkReal x376=(r11*sj4*sj5);
IkReal x377=(r21*sj4*sj5);
IkReal x378=((((0.013)*x373))+(((-1.0)*(4.0)*pz))+(((1.6736)*x371))+(((0.013)*x372))+(((-0.14022)*x374))+(((0.14022)*x376))+(((-1.6736)*x375))+(((1.6736)*x377))+(((0.14022)*x370)));
IkReal x379=((((-5.0208)*x375))+(((-1.0)*(12.0)*pz))+(((-0.42066)*x374))+(((5.0208)*x371))+(((0.42066)*x376))+(((0.42066)*x370))+(((0.039)*x373))+(((5.0208)*x377))+(((0.039)*x372)));
op[0]=((-1.76)+x378);
op[1]=0;
op[2]=((-1.76)+x379);
op[3]=0;
op[4]=((1.76)+x379);
op[5]=0;
op[6]=((1.76)+x378);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x380=(cj4*r12);
IkReal x381=(cj5*r11);
IkReal x382=(cj5*r21);
IkReal x383=(r10*sj5);
IkReal x384=(r20*sj5);
IkReal x385=(cj5*r10*sj4);
IkReal x386=(r11*sj4*sj5);
IkReal x387=((((0.7051496521)*x380))+(((0.0054392)*x381))+(((0.000455715)*x382))+(((-1.0)*(0.14022)*pz))+(((0.000455715)*x384))+(((0.0054392)*x383))+(((-0.7051496521)*x385))+(((0.7051496521)*x386))+(((-1.0)*(1.6736)*py)));
IkReal x388=((((-1.0)*(0.42066)*pz))+(((0.0163176)*x383))+(((-1.0)*(5.0208)*py))+(((2.1154489563)*x386))+(((-2.1154489563)*x385))+(((0.001367145)*x384))+(((2.1154489563)*x380))+(((0.0163176)*x381))+(((0.001367145)*x382)));
j1evalpoly[0]=((0.1453768)+(((2.945536)*(htj1*htj1*htj1)))+(((htj1*htj1)*(((0.3127368)+x388))))+(((1.472768)*(htj1*htj1*htj1*htj1*htj1)))+x387+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.0219832)+x387))))+(((htj1*htj1*htj1*htj1)*(((0.1893432)+x388))))+(((1.472768)*htj1)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x389=(cj1*cj4);
IkReal x390=(cj4*sj1);
IkReal x391=(cj1*sj4*sj5);
IkReal x392=(sj1*sj4*sj5);
IkReal x393=(cj5*r20);
IkReal x394=((1.0)*cj1*sj4);
IkReal x395=(cj5*r10);
if( IKabs(((((-1.0)*x393*x394))+((r21*x391))+(((-1.0)*sj1*sj4*x395))+((r11*x392))+((r22*x389))+((r12*x390)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj1*sj4*x393))+((r12*x389))+((r11*x391))+(((-1.0)*r22*x390))+(((-1.0)*r21*x392))+(((-1.0)*x394*x395)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x393*x394))+((r21*x391))+(((-1.0)*sj1*sj4*x395))+((r11*x392))+((r22*x389))+((r12*x390))))+IKsqr((((sj1*sj4*x393))+((r12*x389))+((r11*x391))+(((-1.0)*r22*x390))+(((-1.0)*r21*x392))+(((-1.0)*x394*x395))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x393*x394))+((r21*x391))+(((-1.0)*sj1*sj4*x395))+((r11*x392))+((r22*x389))+((r12*x390))), (((sj1*sj4*x393))+((r12*x389))+((r11*x391))+(((-1.0)*r22*x390))+(((-1.0)*r21*x392))+(((-1.0)*x394*x395))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x396=IKcos(j2);
IkReal x397=(cj1*x396);
IkReal x398=IKsin(j2);
IkReal x399=(sj1*x398);
IkReal x400=(x399+x397);
IkReal x401=((1.0)*cj4);
IkReal x402=(cj5*sj4);
IkReal x403=((1.0)*sj4*sj5);
IkReal x404=(cj1*x398);
IkReal x405=(sj1*x396);
IkReal x406=(cj5*sj3);
IkReal x407=(sj3*sj5);
IkReal x408=((1.0)*cj3*sj4);
IkReal x409=(cj3*cj4*sj5);
IkReal x410=((1.0)*cj3*cj4*cj5);
IkReal x411=((0.00325)*cj5);
IkReal x412=((0.00325)*sj5);
evalcond[0]=(((r10*x402))+(((-1.0)*r11*x403))+(((-1.0)*r12*x401))+x400);
evalcond[1]=(((r20*x402))+(((-1.0)*r21*x403))+x404+(((-1.0)*r22*x401))+(((-1.0)*x405)));
evalcond[2]=(((r21*x409))+((r21*x406))+x400+(((-1.0)*r22*x408))+(((-1.0)*r20*x410))+((r20*x407)));
evalcond[3]=(((r11*x406))+(((-1.0)*x404))+(((-1.0)*r12*x408))+((r10*x407))+x405+(((-1.0)*r10*x410))+((r11*x409)));
evalcond[4]=(((r21*x411))+(((-1.0)*(1.0)*pz))+(((0.44)*cj1))+(((-0.4184)*x405))+(((0.4184)*x404))+(((0.035055)*x399))+(((0.035055)*x397))+((r20*x412)));
evalcond[5]=((0.05)+(((-1.0)*(1.0)*py))+(((-0.035055)*x404))+((r11*x411))+(((0.44)*sj1))+(((0.035055)*x405))+((r10*x412))+(((0.4184)*x399))+(((0.4184)*x397)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x413=(((r21*sj4*sj5))+(((-1.0)*(1.0)*cj5*r20*sj4))+((cj4*r22)));
IkReal x414=((1.0)*r11);
j3eval[0]=x413;
j3eval[1]=IKsign(x413);
j3eval[2]=((IKabs((((r12*sj4))+(((-1.0)*cj4*sj5*x414))+((cj4*cj5*r10)))))+(IKabs(((((-1.0)*(1.0)*r10*sj5))+(((-1.0)*cj5*x414))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x415=((1.0)*cj4);
IkReal x416=((1.0)*sj5);
IkReal x417=(((cj5*r10*sj4))+(((-1.0)*r12*x415))+(((-1.0)*r11*sj4*x416)));
j3eval[0]=x417;
j3eval[1]=((IKabs(((((-1.0)*r21*sj5*x415))+((r22*sj4))+((cj4*cj5*r20)))))+(IKabs(((((-1.0)*r20*x416))+(((-1.0)*(1.0)*cj5*r21))))));
j3eval[2]=IKsign(x417);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x418=r00*r00;
IkReal x419=r02*r02;
IkReal x420=((2.0)*cj5);
IkReal x421=(r00*r01*sj5*x420);
IkReal x422=cj4*cj4;
IkReal x423=r01*r01;
IkReal x424=(x422*x423);
IkReal x425=cj5*cj5;
IkReal x426=(cj4*r01*sj5);
IkReal x427=(x418*x425);
IkReal x428=((((-1.0)*x424*x425))+(((-1.0)*x421*x422))+x418+x419+(((-2.0)*r02*sj4*x426))+((x422*x427))+((cj4*r00*r02*sj4*x420))+x421+x424+(((-1.0)*x419*x422))+(((-1.0)*x427))+((x423*x425)));
IkReal x429=((1.0)*cj5);
j3eval[0]=x428;
j3eval[1]=((IKabs(((((-1.0)*r00*sj5))+(((-1.0)*r01*x429)))))+(IKabs(((((-1.0)*cj4*r00*x429))+x426+(((-1.0)*r02*sj4))))));
j3eval[2]=IKsign(x428);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x430=(cj4*r01*sj5);
IkReal x431=((1.0)*cj5);
IkReal x432=r00*r00;
IkReal x433=r02*r02;
IkReal x434=((2.0)*cj5);
IkReal x435=(r00*r01*sj5*x434);
IkReal x436=cj4*cj4;
IkReal x437=r01*r01;
IkReal x438=(x436*x437);
IkReal x439=cj5*cj5;
IkReal x440=(x432*x439);
CheckValue<IkReal> x441=IKPowWithIntegerCheck(IKsign(((((-1.0)*x440))+((x436*x440))+(((-1.0)*x435*x436))+(((-1.0)*x433*x436))+(((-2.0)*r02*sj4*x430))+((cj4*r00*r02*sj4*x434))+x438+x435+x432+x433+(((-1.0)*x438*x439))+((x437*x439)))),-1);
if(!x441.valid){
continue;
}
CheckValue<IkReal> x442 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*r00*x431))+(((-1.0)*r02*sj4))+x430)),IkReal(((((-1.0)*r00*sj5))+(((-1.0)*r01*x431)))),IKFAST_ATAN2_MAGTHRESH);
if(!x442.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x441.value)))+(x442.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x443=IKsin(j3);
IkReal x444=(cj5*r01);
IkReal x445=(r00*sj5);
IkReal x446=(r02*sj4);
IkReal x447=IKcos(j3);
IkReal x448=((1.0)*x447);
IkReal x449=(cj4*r01*sj5);
IkReal x450=(cj4*r00);
IkReal x451=((1.0)*cj5*x447);
IkReal x452=((1.0)*sj5*x447);
IkReal x453=((1.0)*sj4*x443);
IkReal x454=(cj4*sj5*x443);
IkReal x455=((1.0)*cj4*cj5*x443);
evalcond[0]=(((x443*x444))+((x447*x449))+(((-1.0)*x450*x451))+(((-1.0)*x446*x448))+((x443*x445)));
evalcond[1]=((((-1.0)*r20*x455))+(((-1.0)*r20*x452))+(((-1.0)*r22*x453))+(((-1.0)*r21*x451))+((r21*x454)));
evalcond[2]=((((-1.0)*r12*x453))+(((-1.0)*r10*x452))+(((-1.0)*r10*x455))+(((-1.0)*r11*x451))+((r11*x454)));
evalcond[3]=((-1.0)+(((-1.0)*x443*x446))+(((-1.0)*cj5*x443*x450))+((x443*x449))+(((-1.0)*x445*x448))+(((-1.0)*x444*x448)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x456=(cj4*r22);
IkReal x457=(cj5*r20*sj4);
IkReal x458=(r21*sj4*sj5);
IkReal x459=(cj5*r21);
IkReal x460=(r20*sj5);
IkReal x461=(cj3*r22*sj4);
IkReal x462=(cj5*r21*sj3);
IkReal x463=(r20*sj3*sj5);
IkReal x464=(cj3*cj4*cj5*r20);
IkReal x465=(cj3*cj4*r21*sj5);
IkReal x466=((-1.76)+(((0.14022)*x461))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x465))+(((0.013)*x460))+(((0.013)*x459))+(((-0.14022)*x462))+(((0.14022)*x464))+(((-0.14022)*x463)));
IkReal x467=((-1.0)*(((12.0)*pz)));
IkReal x468=((0.039)*x459);
IkReal x469=((0.039)*x460);
IkReal x470=((0.42066)*x461);
IkReal x471=((-0.42066)*x462);
IkReal x472=((-0.42066)*x463);
IkReal x473=((0.42066)*x464);
IkReal x474=((-0.42066)*x465);
IkReal x475=(x470+x471+x472+x473+x474+(((5.0208)*x458))+(((-5.0208)*x457))+(((5.0208)*x456))+x467+x468+x469);
IkReal x476=(cj3*r12*sj4);
IkReal x477=(cj5*r11*sj3);
IkReal x478=(r10*sj3*sj5);
IkReal x479=(cj3*cj4*cj5*r10);
IkReal x480=(cj3*cj4*r11*sj5);
IkReal x481=(x470+x471+x472+x473+x474+(((-5.0208)*x477))+(((-5.0208)*x478))+(((5.0208)*x479))+(((5.0208)*x476))+(((-5.0208)*x480))+x467+x468+x469);
j1eval[0]=((IKabs(((-1.76)+x475)))+(IKabs(((1.76)+x475)))+(IKabs(((-1.76)+x481)))+(IKabs(((((1.6736)*x479))+(((-1.6736)*x480))+(((-1.6736)*x477))+(((1.6736)*x476))+(((-1.6736)*x478))+x466)))+(IKabs(((((-1.6736)*x457))+(((1.6736)*x458))+(((1.6736)*x456))+x466)))+(IKabs(((1.76)+x481))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x482=(cj4*r22);
IkReal x483=(cj5*r21);
IkReal x484=(r20*sj5);
IkReal x485=(cj3*r22*sj4);
IkReal x486=(cj5*r20*sj4);
IkReal x487=(cj5*r21*sj3);
IkReal x488=(r20*sj3*sj5);
IkReal x489=(r21*sj4*sj5);
IkReal x490=(cj3*cj4*cj5*r20);
IkReal x491=(cj3*cj4*r21*sj5);
IkReal x492=((((-1.6736)*x486))+(((-0.14022)*x491))+(((-1.0)*(4.0)*pz))+(((1.6736)*x482))+(((0.14022)*x490))+(((1.6736)*x489))+(((0.013)*x484))+(((-0.14022)*x488))+(((-0.14022)*x487))+(((0.013)*x483))+(((0.14022)*x485)));
IkReal x493=((((0.42066)*x485))+(((5.0208)*x482))+(((-0.42066)*x487))+(((-1.0)*(12.0)*pz))+(((0.039)*x483))+(((0.039)*x484))+(((-0.42066)*x491))+(((-5.0208)*x486))+(((0.42066)*x490))+(((-0.42066)*x488))+(((5.0208)*x489)));
op[0]=((-1.76)+x492);
op[1]=0;
op[2]=((-1.76)+x493);
op[3]=0;
op[4]=((1.76)+x493);
op[5]=0;
op[6]=((1.76)+x492);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x494=(cj5*r21);
IkReal x495=(r20*sj5);
IkReal x496=(cj3*r12*sj4);
IkReal x497=(cj3*r22*sj4);
IkReal x498=(cj5*r11*sj3);
IkReal x499=(cj5*r21*sj3);
IkReal x500=(r10*sj3*sj5);
IkReal x501=(r20*sj3*sj5);
IkReal x502=(cj3*cj4*cj5*r10);
IkReal x503=x490;
IkReal x504=(cj3*cj4*r11*sj5);
IkReal x505=x491;
IkReal x506=((((0.14022)*x497))+(((1.6736)*x502))+(((0.013)*x495))+(((-0.14022)*x501))+(((-1.0)*(4.0)*pz))+(((-1.6736)*x498))+(((-0.14022)*x505))+(((1.6736)*x496))+(((0.013)*x494))+(((-1.6736)*x504))+(((-0.14022)*x499))+(((-1.6736)*x500))+(((0.14022)*x503)));
IkReal x507=((((5.0208)*x502))+(((0.039)*x495))+(((-1.0)*(12.0)*pz))+(((-0.42066)*x505))+(((0.42066)*x503))+(((-5.0208)*x500))+(((-5.0208)*x504))+(((0.039)*x494))+(((-5.0208)*x498))+(((-0.42066)*x499))+(((5.0208)*x496))+(((0.42066)*x497))+(((-0.42066)*x501)));
j1evalpoly[0]=((1.76)+(((htj1*htj1)*(((1.76)+x507))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.76)+x506))))+x506+(((htj1*htj1*htj1*htj1)*(((-1.76)+x507)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x508=(cj1*cj4);
IkReal x509=((1.0)*r12);
IkReal x510=(cj4*sj1);
IkReal x511=(cj1*sj4*sj5);
IkReal x512=(cj5*r10);
IkReal x513=(sj1*sj4);
IkReal x514=(cj5*r20);
IkReal x515=((1.0)*r11);
IkReal x516=(sj1*sj4*sj5);
if( IKabs(((((-1.0)*x509*x510))+(((-1.0)*x515*x516))+((r22*x508))+(((-1.0)*cj1*sj4*x514))+((r21*x511))+((x512*x513)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r22*x510))+((cj1*sj4*x512))+(((-1.0)*x511*x515))+(((-1.0)*r21*x516))+((x513*x514))+(((-1.0)*x508*x509)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x509*x510))+(((-1.0)*x515*x516))+((r22*x508))+(((-1.0)*cj1*sj4*x514))+((r21*x511))+((x512*x513))))+IKsqr(((((-1.0)*r22*x510))+((cj1*sj4*x512))+(((-1.0)*x511*x515))+(((-1.0)*r21*x516))+((x513*x514))+(((-1.0)*x508*x509))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x509*x510))+(((-1.0)*x515*x516))+((r22*x508))+(((-1.0)*cj1*sj4*x514))+((r21*x511))+((x512*x513))), ((((-1.0)*r22*x510))+((cj1*sj4*x512))+(((-1.0)*x511*x515))+(((-1.0)*r21*x516))+((x513*x514))+(((-1.0)*x508*x509))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x517=IKsin(j2);
IkReal x518=(cj1*x517);
IkReal x519=IKcos(j2);
IkReal x520=(sj1*x519);
IkReal x521=((((-1.0)*x520))+x518);
IkReal x522=((1.0)*cj4);
IkReal x523=(cj5*sj4);
IkReal x524=((1.0)*sj4*sj5);
IkReal x525=(cj1*x519);
IkReal x526=(sj1*x517);
IkReal x527=(cj5*sj3);
IkReal x528=(sj3*sj5);
IkReal x529=((1.0)*cj3*sj4);
IkReal x530=(cj3*cj4*sj5);
IkReal x531=((1.0)*cj3*cj4*cj5);
IkReal x532=((0.00325)*cj5);
IkReal x533=((0.00325)*sj5);
evalcond[0]=(((r20*x523))+(((-1.0)*r21*x524))+(((-1.0)*r22*x522))+x521);
evalcond[1]=(((r10*x523))+(((-1.0)*r11*x524))+(((-1.0)*x526))+(((-1.0)*r12*x522))+(((-1.0)*x525)));
evalcond[2]=(((r21*x530))+(((-1.0)*r20*x531))+(((-1.0)*r22*x529))+((r20*x528))+((r21*x527))+x525+x526);
evalcond[3]=(((r11*x530))+((r11*x527))+((r10*x528))+(((-1.0)*r12*x529))+(((-1.0)*r10*x531))+x521);
evalcond[4]=(((r20*x533))+(((-1.0)*(1.0)*pz))+(((0.44)*cj1))+((r21*x532))+(((-0.4184)*x520))+(((0.4184)*x518))+(((0.035055)*x526))+(((0.035055)*x525)));
evalcond[5]=((-0.05)+(((-1.0)*(0.44)*sj1))+(((-1.0)*(1.0)*py))+((r10*x533))+(((-0.4184)*x526))+(((-0.035055)*x520))+(((0.035055)*x518))+((r11*x532))+(((-0.4184)*x525)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x534=((1.0)*cj4);
IkReal x535=((1.0)*sj5);
CheckValue<IkReal> x536=IKPowWithIntegerCheck(IKsign(((((-1.0)*r11*sj4*x535))+((cj5*r10*sj4))+(((-1.0)*r12*x534)))),-1);
if(!x536.valid){
continue;
}
CheckValue<IkReal> x537 = IKatan2WithCheck(IkReal(((((-1.0)*(1.0)*cj5*r21))+(((-1.0)*r20*x535)))),IkReal(((((-1.0)*r21*sj5*x534))+((r22*sj4))+((cj4*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x537.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x536.value)))+(x537.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x538=IKsin(j3);
IkReal x539=(cj5*r01);
IkReal x540=(r00*sj5);
IkReal x541=(r02*sj4);
IkReal x542=IKcos(j3);
IkReal x543=((1.0)*x542);
IkReal x544=(cj4*r01*sj5);
IkReal x545=(cj4*r00);
IkReal x546=((1.0)*cj5*x542);
IkReal x547=((1.0)*sj5*x542);
IkReal x548=((1.0)*sj4*x538);
IkReal x549=(cj4*sj5*x538);
IkReal x550=((1.0)*cj4*cj5*x538);
evalcond[0]=((((-1.0)*x545*x546))+((x538*x539))+(((-1.0)*x541*x543))+((x538*x540))+((x542*x544)));
evalcond[1]=(((r21*x549))+(((-1.0)*r20*x550))+(((-1.0)*r20*x547))+(((-1.0)*r21*x546))+(((-1.0)*r22*x548)));
evalcond[2]=((((-1.0)*r10*x547))+((r11*x549))+(((-1.0)*r11*x546))+(((-1.0)*r10*x550))+(((-1.0)*r12*x548)));
evalcond[3]=((-1.0)+(((-1.0)*cj5*x538*x545))+(((-1.0)*x538*x541))+(((-1.0)*x540*x543))+(((-1.0)*x539*x543))+((x538*x544)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x551=(cj4*r22);
IkReal x552=(cj5*r20*sj4);
IkReal x553=(r21*sj4*sj5);
IkReal x554=(cj5*r21);
IkReal x555=(r20*sj5);
IkReal x556=(cj3*r22*sj4);
IkReal x557=(cj5*r21*sj3);
IkReal x558=(r20*sj3*sj5);
IkReal x559=(cj3*cj4*cj5*r20);
IkReal x560=(cj3*cj4*r21*sj5);
IkReal x561=((-1.76)+(((0.14022)*x556))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x558))+(((-0.14022)*x560))+(((-0.14022)*x557))+(((0.14022)*x559))+(((0.013)*x555))+(((0.013)*x554)));
IkReal x562=((-1.0)*(((12.0)*pz)));
IkReal x563=((0.039)*x554);
IkReal x564=((0.039)*x555);
IkReal x565=((0.42066)*x556);
IkReal x566=((-0.42066)*x557);
IkReal x567=((-0.42066)*x558);
IkReal x568=((0.42066)*x559);
IkReal x569=((-0.42066)*x560);
IkReal x570=((((-5.0208)*x552))+(((5.0208)*x551))+(((5.0208)*x553))+x562+x563+x564+x565+x566+x567+x568+x569);
IkReal x571=(cj3*r12*sj4);
IkReal x572=(cj5*r11*sj3);
IkReal x573=(r10*sj3*sj5);
IkReal x574=(cj3*cj4*cj5*r10);
IkReal x575=(cj3*cj4*r11*sj5);
IkReal x576=((((-5.0208)*x573))+(((5.0208)*x571))+(((-5.0208)*x572))+(((-5.0208)*x575))+(((5.0208)*x574))+x562+x563+x564+x565+x566+x567+x568+x569);
j1eval[0]=((IKabs(((-1.76)+x570)))+(IKabs(((((1.6736)*x551))+(((1.6736)*x553))+(((-1.6736)*x552))+x561)))+(IKabs(((1.76)+x570)))+(IKabs(((-1.76)+x576)))+(IKabs(((((1.6736)*x571))+(((1.6736)*x574))+(((-1.6736)*x572))+(((-1.6736)*x573))+(((-1.6736)*x575))+x561)))+(IKabs(((1.76)+x576))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x577=(cj4*r22);
IkReal x578=(cj5*r21);
IkReal x579=(r20*sj5);
IkReal x580=(cj3*r22*sj4);
IkReal x581=(cj5*r20*sj4);
IkReal x582=(cj5*r21*sj3);
IkReal x583=(r20*sj3*sj5);
IkReal x584=(r21*sj4*sj5);
IkReal x585=(cj3*cj4*cj5*r20);
IkReal x586=(cj3*cj4*r21*sj5);
IkReal x587=((((1.6736)*x577))+(((-0.14022)*x583))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x586))+(((0.14022)*x585))+(((0.14022)*x580))+(((0.013)*x579))+(((0.013)*x578))+(((1.6736)*x584))+(((-0.14022)*x582))+(((-1.6736)*x581)));
IkReal x588=((((0.039)*x579))+(((0.039)*x578))+(((-1.0)*(12.0)*pz))+(((5.0208)*x577))+(((-0.42066)*x586))+(((5.0208)*x584))+(((-5.0208)*x581))+(((-0.42066)*x583))+(((0.42066)*x585))+(((0.42066)*x580))+(((-0.42066)*x582)));
op[0]=((-1.76)+x587);
op[1]=0;
op[2]=((-1.76)+x588);
op[3]=0;
op[4]=((1.76)+x588);
op[5]=0;
op[6]=((1.76)+x587);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x589=(cj5*r21);
IkReal x590=(r20*sj5);
IkReal x591=(cj3*r12*sj4);
IkReal x592=(cj3*r22*sj4);
IkReal x593=(cj5*r11*sj3);
IkReal x594=(cj5*r21*sj3);
IkReal x595=(r10*sj3*sj5);
IkReal x596=(r20*sj3*sj5);
IkReal x597=(cj3*cj4*cj5*r10);
IkReal x598=x585;
IkReal x599=(cj3*cj4*r11*sj5);
IkReal x600=x586;
IkReal x601=((((-1.6736)*x595))+(((-1.0)*(4.0)*pz))+(((-1.6736)*x599))+(((-0.14022)*x600))+(((-0.14022)*x594))+(((0.013)*x589))+(((1.6736)*x591))+(((-0.14022)*x596))+(((0.013)*x590))+(((-1.6736)*x593))+(((0.14022)*x598))+(((0.14022)*x592))+(((1.6736)*x597)));
IkReal x602=((((5.0208)*x591))+(((0.039)*x590))+(((-1.0)*(12.0)*pz))+(((-5.0208)*x593))+(((-0.42066)*x596))+(((-5.0208)*x595))+(((0.039)*x589))+(((5.0208)*x597))+(((0.42066)*x598))+(((-5.0208)*x599))+(((0.42066)*x592))+(((-0.42066)*x594))+(((-0.42066)*x600)));
j1evalpoly[0]=((1.76)+(((htj1*htj1*htj1*htj1)*(((-1.76)+x602))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.76)+x601))))+(((htj1*htj1)*(((1.76)+x602))))+x601);
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x603=(cj1*cj4);
IkReal x604=((1.0)*r12);
IkReal x605=(cj4*sj1);
IkReal x606=(cj1*sj4*sj5);
IkReal x607=(cj5*r10);
IkReal x608=(sj1*sj4);
IkReal x609=(cj5*r20);
IkReal x610=((1.0)*r11);
IkReal x611=(sj1*sj4*sj5);
if( IKabs(((((-1.0)*x610*x611))+(((-1.0)*x604*x605))+(((-1.0)*cj1*sj4*x609))+((r21*x606))+((x607*x608))+((r22*x603)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x608*x609))+(((-1.0)*x603*x604))+(((-1.0)*r21*x611))+(((-1.0)*x606*x610))+((cj1*sj4*x607))+(((-1.0)*r22*x605)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x610*x611))+(((-1.0)*x604*x605))+(((-1.0)*cj1*sj4*x609))+((r21*x606))+((x607*x608))+((r22*x603))))+IKsqr((((x608*x609))+(((-1.0)*x603*x604))+(((-1.0)*r21*x611))+(((-1.0)*x606*x610))+((cj1*sj4*x607))+(((-1.0)*r22*x605))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x610*x611))+(((-1.0)*x604*x605))+(((-1.0)*cj1*sj4*x609))+((r21*x606))+((x607*x608))+((r22*x603))), (((x608*x609))+(((-1.0)*x603*x604))+(((-1.0)*r21*x611))+(((-1.0)*x606*x610))+((cj1*sj4*x607))+(((-1.0)*r22*x605))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x612=IKsin(j2);
IkReal x613=(cj1*x612);
IkReal x614=IKcos(j2);
IkReal x615=(sj1*x614);
IkReal x616=(x613+(((-1.0)*x615)));
IkReal x617=((1.0)*cj4);
IkReal x618=(cj5*sj4);
IkReal x619=((1.0)*sj4*sj5);
IkReal x620=(cj1*x614);
IkReal x621=(sj1*x612);
IkReal x622=(cj5*sj3);
IkReal x623=(sj3*sj5);
IkReal x624=((1.0)*cj3*sj4);
IkReal x625=(cj3*cj4*sj5);
IkReal x626=((1.0)*cj3*cj4*cj5);
IkReal x627=((0.00325)*cj5);
IkReal x628=((0.00325)*sj5);
evalcond[0]=(x616+((r20*x618))+(((-1.0)*r22*x617))+(((-1.0)*r21*x619)));
evalcond[1]=((((-1.0)*x620))+(((-1.0)*r12*x617))+((r10*x618))+(((-1.0)*r11*x619))+(((-1.0)*x621)));
evalcond[2]=((((-1.0)*r20*x626))+((r21*x622))+((r21*x625))+x620+x621+(((-1.0)*r22*x624))+((r20*x623)));
evalcond[3]=(x616+((r10*x623))+((r11*x625))+(((-1.0)*r10*x626))+(((-1.0)*r12*x624))+((r11*x622)));
evalcond[4]=((((0.035055)*x621))+(((-1.0)*(1.0)*pz))+(((0.44)*cj1))+((r20*x628))+(((0.4184)*x613))+((r21*x627))+(((-0.4184)*x615))+(((0.035055)*x620)));
evalcond[5]=((-0.05)+(((-0.035055)*x615))+(((-1.0)*(0.44)*sj1))+(((-1.0)*(1.0)*py))+(((-0.4184)*x621))+(((0.035055)*x613))+(((-0.4184)*x620))+((r11*x627))+((r10*x628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x629=((1.0)*r11);
CheckValue<IkReal> x630=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+(((-1.0)*(1.0)*cj5*r20*sj4))+((cj4*r22)))),-1);
if(!x630.valid){
continue;
}
CheckValue<IkReal> x631 = IKatan2WithCheck(IkReal(((((-1.0)*(1.0)*r10*sj5))+(((-1.0)*cj5*x629)))),IkReal((((r12*sj4))+(((-1.0)*cj4*sj5*x629))+((cj4*cj5*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x631.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x630.value)))+(x631.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x632=IKsin(j3);
IkReal x633=(cj5*r01);
IkReal x634=(r00*sj5);
IkReal x635=(r02*sj4);
IkReal x636=IKcos(j3);
IkReal x637=((1.0)*x636);
IkReal x638=(cj4*r01*sj5);
IkReal x639=(cj4*r00);
IkReal x640=((1.0)*cj5*x636);
IkReal x641=((1.0)*sj5*x636);
IkReal x642=((1.0)*sj4*x632);
IkReal x643=(cj4*sj5*x632);
IkReal x644=((1.0)*cj4*cj5*x632);
evalcond[0]=(((x632*x634))+((x636*x638))+((x632*x633))+(((-1.0)*x639*x640))+(((-1.0)*x635*x637)));
evalcond[1]=((((-1.0)*r20*x644))+(((-1.0)*r20*x641))+(((-1.0)*r21*x640))+(((-1.0)*r22*x642))+((r21*x643)));
evalcond[2]=((((-1.0)*r10*x641))+(((-1.0)*r12*x642))+(((-1.0)*r11*x640))+((r11*x643))+(((-1.0)*r10*x644)));
evalcond[3]=((-1.0)+(((-1.0)*cj5*x632*x639))+(((-1.0)*x633*x637))+(((-1.0)*x634*x637))+(((-1.0)*x632*x635))+((x632*x638)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x645=(cj4*r22);
IkReal x646=(cj5*r20*sj4);
IkReal x647=(r21*sj4*sj5);
IkReal x648=(cj5*r21);
IkReal x649=(r20*sj5);
IkReal x650=(cj3*r22*sj4);
IkReal x651=(cj5*r21*sj3);
IkReal x652=(r20*sj3*sj5);
IkReal x653=(cj3*cj4*cj5*r20);
IkReal x654=(cj3*cj4*r21*sj5);
IkReal x655=((-1.76)+(((-0.14022)*x651))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x654))+(((0.14022)*x650))+(((-0.14022)*x652))+(((0.013)*x649))+(((0.14022)*x653))+(((0.013)*x648)));
IkReal x656=((-1.0)*(((12.0)*pz)));
IkReal x657=((0.039)*x648);
IkReal x658=((0.039)*x649);
IkReal x659=((0.42066)*x650);
IkReal x660=((-0.42066)*x651);
IkReal x661=((-0.42066)*x652);
IkReal x662=((0.42066)*x653);
IkReal x663=((-0.42066)*x654);
IkReal x664=((((5.0208)*x645))+(((-5.0208)*x646))+(((5.0208)*x647))+x658+x659+x656+x657+x663+x662+x661+x660);
IkReal x665=(cj3*r12*sj4);
IkReal x666=(cj5*r11*sj3);
IkReal x667=(r10*sj3*sj5);
IkReal x668=(cj3*cj4*cj5*r10);
IkReal x669=(cj3*cj4*r11*sj5);
IkReal x670=((((-5.0208)*x669))+(((-5.0208)*x667))+(((5.0208)*x665))+(((-5.0208)*x666))+x658+x659+x656+x657+(((5.0208)*x668))+x663+x662+x661+x660);
j1eval[0]=((IKabs(((-1.76)+x670)))+(IKabs(((1.76)+x670)))+(IKabs(((-1.76)+x664)))+(IKabs(((1.76)+x664)))+(IKabs(((((1.6736)*x645))+(((-1.6736)*x646))+(((1.6736)*x647))+x655)))+(IKabs(((((-1.6736)*x666))+(((1.6736)*x665))+x655+(((1.6736)*x668))+(((-1.6736)*x667))+(((-1.6736)*x669))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x671=(cj4*r22);
IkReal x672=(cj5*r21);
IkReal x673=(r20*sj5);
IkReal x674=(cj3*r22*sj4);
IkReal x675=(cj5*r20*sj4);
IkReal x676=(cj5*r21*sj3);
IkReal x677=(r20*sj3*sj5);
IkReal x678=(r21*sj4*sj5);
IkReal x679=(cj3*cj4*cj5*r20);
IkReal x680=(cj3*cj4*r21*sj5);
IkReal x681=((((1.6736)*x671))+(((-0.14022)*x676))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x677))+(((1.6736)*x678))+(((0.14022)*x679))+(((-1.6736)*x675))+(((-0.14022)*x680))+(((0.14022)*x674))+(((0.013)*x673))+(((0.013)*x672)));
IkReal x682=((((-0.42066)*x680))+(((-1.0)*(12.0)*pz))+(((0.039)*x673))+(((5.0208)*x678))+(((0.42066)*x679))+(((-0.42066)*x677))+(((-5.0208)*x675))+(((-0.42066)*x676))+(((0.42066)*x674))+(((5.0208)*x671))+(((0.039)*x672)));
op[0]=((-1.76)+x681);
op[1]=0;
op[2]=((-1.76)+x682);
op[3]=0;
op[4]=((1.76)+x682);
op[5]=0;
op[6]=((1.76)+x681);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x683=(cj5*r21);
IkReal x684=(r20*sj5);
IkReal x685=(cj3*r12*sj4);
IkReal x686=(cj3*r22*sj4);
IkReal x687=(cj5*r11*sj3);
IkReal x688=(cj5*r21*sj3);
IkReal x689=(r10*sj3*sj5);
IkReal x690=(r20*sj3*sj5);
IkReal x691=(cj3*cj4*cj5*r10);
IkReal x692=x679;
IkReal x693=(cj3*cj4*r11*sj5);
IkReal x694=x680;
IkReal x695=((((0.14022)*x686))+(((1.6736)*x685))+(((0.013)*x683))+(((-1.6736)*x693))+(((-0.14022)*x694))+(((-1.0)*(4.0)*pz))+(((-1.6736)*x689))+(((-0.14022)*x688))+(((-0.14022)*x690))+(((-1.6736)*x687))+(((0.013)*x684))+(((0.14022)*x692))+(((1.6736)*x691)));
IkReal x696=((((-1.0)*(12.0)*pz))+(((0.039)*x684))+(((-5.0208)*x693))+(((-5.0208)*x689))+(((-0.42066)*x694))+(((0.42066)*x692))+(((0.42066)*x686))+(((5.0208)*x691))+(((5.0208)*x685))+(((-0.42066)*x690))+(((-0.42066)*x688))+(((-5.0208)*x687))+(((0.039)*x683)));
j1evalpoly[0]=((1.76)+(((htj1*htj1)*(((1.76)+x696))))+(((htj1*htj1*htj1*htj1)*(((-1.76)+x696))))+x695+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.76)+x695)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x697=(cj1*cj4);
IkReal x698=((1.0)*r12);
IkReal x699=(cj4*sj1);
IkReal x700=(cj1*sj4*sj5);
IkReal x701=(cj5*r10);
IkReal x702=(sj1*sj4);
IkReal x703=(cj5*r20);
IkReal x704=((1.0)*r11);
IkReal x705=(sj1*sj4*sj5);
if( IKabs(((((-1.0)*x704*x705))+((r21*x700))+(((-1.0)*cj1*sj4*x703))+((r22*x697))+(((-1.0)*x698*x699))+((x701*x702)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x697*x698))+((x702*x703))+(((-1.0)*x700*x704))+(((-1.0)*r22*x699))+((cj1*sj4*x701))+(((-1.0)*r21*x705)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x704*x705))+((r21*x700))+(((-1.0)*cj1*sj4*x703))+((r22*x697))+(((-1.0)*x698*x699))+((x701*x702))))+IKsqr(((((-1.0)*x697*x698))+((x702*x703))+(((-1.0)*x700*x704))+(((-1.0)*r22*x699))+((cj1*sj4*x701))+(((-1.0)*r21*x705))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x704*x705))+((r21*x700))+(((-1.0)*cj1*sj4*x703))+((r22*x697))+(((-1.0)*x698*x699))+((x701*x702))), ((((-1.0)*x697*x698))+((x702*x703))+(((-1.0)*x700*x704))+(((-1.0)*r22*x699))+((cj1*sj4*x701))+(((-1.0)*r21*x705))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x706=IKsin(j2);
IkReal x707=(cj1*x706);
IkReal x708=IKcos(j2);
IkReal x709=(sj1*x708);
IkReal x710=((((-1.0)*x709))+x707);
IkReal x711=((1.0)*cj4);
IkReal x712=(cj5*sj4);
IkReal x713=((1.0)*sj4*sj5);
IkReal x714=(cj1*x708);
IkReal x715=(sj1*x706);
IkReal x716=(cj5*sj3);
IkReal x717=(sj3*sj5);
IkReal x718=((1.0)*cj3*sj4);
IkReal x719=(cj3*cj4*sj5);
IkReal x720=((1.0)*cj3*cj4*cj5);
IkReal x721=((0.00325)*cj5);
IkReal x722=((0.00325)*sj5);
evalcond[0]=((((-1.0)*r21*x713))+(((-1.0)*r22*x711))+x710+((r20*x712)));
evalcond[1]=((((-1.0)*x715))+((r10*x712))+(((-1.0)*r12*x711))+(((-1.0)*r11*x713))+(((-1.0)*x714)));
evalcond[2]=((((-1.0)*r20*x720))+(((-1.0)*r22*x718))+x714+x715+((r20*x717))+((r21*x719))+((r21*x716)));
evalcond[3]=(((r10*x717))+(((-1.0)*r12*x718))+x710+(((-1.0)*r10*x720))+((r11*x719))+((r11*x716)));
evalcond[4]=(((r21*x721))+(((0.035055)*x715))+(((-1.0)*(1.0)*pz))+(((-0.4184)*x709))+(((0.44)*cj1))+(((0.035055)*x714))+((r20*x722))+(((0.4184)*x707)));
evalcond[5]=((-0.05)+(((-1.0)*(0.44)*sj1))+(((-1.0)*(1.0)*py))+((r10*x722))+((r11*x721))+(((-0.4184)*x714))+(((0.035055)*x707))+(((-0.035055)*x709))+(((-0.4184)*x715)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x723=(((r01*sj4*sj5))+((cj4*r02))+(((-1.0)*(1.0)*cj5*r00*sj4)));
IkReal x724=((1.0)*r21);
j3eval[0]=x723;
j3eval[1]=IKsign(x723);
j3eval[2]=((IKabs(((((-1.0)*cj4*sj5*x724))+((r22*sj4))+((cj4*cj5*r20)))))+(IKabs(((((-1.0)*cj5*x724))+(((-1.0)*(1.0)*r20*sj5))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x725=((1.0)*cj4);
IkReal x726=((1.0)*sj5);
IkReal x727=((((-1.0)*r22*x725))+((cj5*r20*sj4))+(((-1.0)*r21*sj4*x726)));
j3eval[0]=x727;
j3eval[1]=((IKabs((((cj4*cj5*r00))+(((-1.0)*r01*sj5*x725))+((r02*sj4)))))+(IKabs(((((-1.0)*(1.0)*cj5*r01))+(((-1.0)*r00*x726))))));
j3eval[2]=IKsign(x727);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x728=r10*r10;
IkReal x729=r12*r12;
IkReal x730=((2.0)*cj5);
IkReal x731=(r10*r11*sj5*x730);
IkReal x732=cj4*cj4;
IkReal x733=r11*r11;
IkReal x734=(x732*x733);
IkReal x735=cj5*cj5;
IkReal x736=(cj4*r11*sj5);
IkReal x737=(x728*x735);
IkReal x738=(((x733*x735))+(((-1.0)*x734*x735))+(((-1.0)*x737))+x731+x734+(((-2.0)*r12*sj4*x736))+((x732*x737))+(((-1.0)*x729*x732))+(((-1.0)*x731*x732))+((cj4*r10*r12*sj4*x730))+x728+x729);
IkReal x739=((1.0)*cj5);
j3eval[0]=x738;
j3eval[1]=IKsign(x738);
j3eval[2]=((IKabs(((((-1.0)*r10*sj5))+(((-1.0)*r11*x739)))))+(IKabs(((((-1.0)*r12*sj4))+x736+(((-1.0)*cj4*r10*x739))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x740=(cj4*r11*sj5);
IkReal x741=((1.0)*cj5);
IkReal x742=r10*r10;
IkReal x743=r12*r12;
IkReal x744=((2.0)*cj5);
IkReal x745=(r10*r11*sj5*x744);
IkReal x746=cj4*cj4;
IkReal x747=r11*r11;
IkReal x748=(x746*x747);
IkReal x749=cj5*cj5;
IkReal x750=(x742*x749);
CheckValue<IkReal> x751=IKPowWithIntegerCheck(IKsign((((cj4*r10*r12*sj4*x744))+(((-1.0)*x750))+(((-1.0)*x745*x746))+((x747*x749))+((x746*x750))+(((-2.0)*r12*sj4*x740))+x748+x742+x743+x745+(((-1.0)*x748*x749))+(((-1.0)*x743*x746)))),-1);
if(!x751.valid){
continue;
}
CheckValue<IkReal> x752 = IKatan2WithCheck(IkReal(((((-1.0)*r12*sj4))+(((-1.0)*cj4*r10*x741))+x740)),IkReal(((((-1.0)*r11*x741))+(((-1.0)*r10*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x752.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x751.value)))+(x752.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x753=IKsin(j3);
IkReal x754=(cj5*r11);
IkReal x755=(r10*sj5);
IkReal x756=IKcos(j3);
IkReal x757=((1.0)*x756);
IkReal x758=((1.0)*cj5*x756);
IkReal x759=((1.0)*sj5*x756);
IkReal x760=((1.0)*sj4*x753);
IkReal x761=(cj4*sj5*x753);
IkReal x762=((1.0)*cj4*cj5*x753);
evalcond[0]=((((-1.0)*r12*sj4*x757))+((x753*x755))+(((-1.0)*cj4*r10*x758))+((x753*x754))+((cj4*r11*sj5*x756)));
evalcond[1]=(((r21*x761))+(((-1.0)*r20*x762))+(((-1.0)*r20*x759))+(((-1.0)*r22*x760))+(((-1.0)*r21*x758)));
evalcond[2]=(((r01*x761))+(((-1.0)*r02*x760))+(((-1.0)*r00*x759))+(((-1.0)*r01*x758))+(((-1.0)*r00*x762)));
evalcond[3]=((-1.0)+((r11*x761))+(((-1.0)*x755*x757))+(((-1.0)*r12*x760))+(((-1.0)*r10*x762))+(((-1.0)*x754*x757)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x763=(cj4*r02);
IkReal x764=(cj5*r01);
IkReal x765=(cj5*r21);
IkReal x766=(r00*sj5);
IkReal x767=(r20*sj5);
IkReal x768=(cj5*r00*sj4);
IkReal x769=(r01*sj4*sj5);
IkReal x770=((((-1.0)*(0.42066)*pz))+(((-1.0)*(5.0208)*px))+(((0.0163176)*x766))+(((0.0163176)*x764))+(((2.1154489563)*x763))+(((2.1154489563)*x769))+(((-2.1154489563)*x768))+(((0.001367145)*x767))+(((0.001367145)*x765)));
IkReal x771=(cj4*r22);
IkReal x772=(cj5*r20*sj4);
IkReal x773=(r21*sj4*sj5);
IkReal x774=((((5.0208)*x773))+(((-1.0)*(12.0)*pz))+(((-0.42066)*x768))+(((0.039)*x765))+(((0.039)*x767))+(((5.0208)*x771))+(((0.42066)*x763))+(((0.42066)*x769))+(((-5.0208)*x772)));
j1eval[0]=((5.891072)+(IKabs(((-1.76)+(((0.14022)*x769))+(((0.14022)*x763))+(((-1.0)*(4.0)*pz))+(((0.013)*x767))+(((1.6736)*x773))+(((-1.6736)*x772))+(((0.013)*x765))+(((-0.14022)*x768))+(((1.6736)*x771)))))+(IKabs(((0.0219832)+(((0.7051496521)*x769))+(((0.7051496521)*x763))+(((-1.0)*(0.14022)*pz))+(((-0.7051496521)*x768))+(((0.000455715)*x767))+(((0.000455715)*x765))+(((0.0054392)*x766))+(((0.0054392)*x764))+(((-1.0)*(1.6736)*px)))))+(IKabs(((-1.76)+x774)))+(IKabs(((1.76)+x774)))+(IKabs(((0.1893432)+x770)))+(IKabs(((0.3127368)+x770))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x775=(cj4*r02);
IkReal x776=(cj4*r22);
IkReal x777=(cj5*r21);
IkReal x778=(r20*sj5);
IkReal x779=(cj5*r00*sj4);
IkReal x780=(cj5*r20*sj4);
IkReal x781=(r01*sj4*sj5);
IkReal x782=(r21*sj4*sj5);
IkReal x783=((((0.013)*x777))+(((-1.0)*(4.0)*pz))+(((0.14022)*x781))+(((-0.14022)*x779))+(((0.14022)*x775))+(((-1.6736)*x780))+(((1.6736)*x782))+(((1.6736)*x776))+(((0.013)*x778)));
IkReal x784=((((-5.0208)*x780))+(((-1.0)*(12.0)*pz))+(((0.42066)*x781))+(((5.0208)*x782))+(((0.42066)*x775))+(((5.0208)*x776))+(((0.039)*x778))+(((0.039)*x777))+(((-0.42066)*x779)));
op[0]=((-1.76)+x783);
op[1]=0;
op[2]=((-1.76)+x784);
op[3]=0;
op[4]=((1.76)+x784);
op[5]=0;
op[6]=((1.76)+x783);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x785=(cj4*r02);
IkReal x786=(cj5*r01);
IkReal x787=(cj5*r21);
IkReal x788=(r00*sj5);
IkReal x789=(r20*sj5);
IkReal x790=(cj5*r00*sj4);
IkReal x791=(r01*sj4*sj5);
IkReal x792=((((0.7051496521)*x791))+(((-1.0)*(0.14022)*pz))+(((-0.7051496521)*x790))+(((0.0054392)*x786))+(((0.000455715)*x789))+(((0.7051496521)*x785))+(((0.000455715)*x787))+(((0.0054392)*x788))+(((-1.0)*(1.6736)*px)));
IkReal x793=((((-1.0)*(0.42066)*pz))+(((-1.0)*(5.0208)*px))+(((0.001367145)*x787))+(((2.1154489563)*x791))+(((-2.1154489563)*x790))+(((0.0163176)*x786))+(((0.0163176)*x788))+(((0.001367145)*x789))+(((2.1154489563)*x785)));
j1evalpoly[0]=((0.1453768)+(((2.945536)*(htj1*htj1*htj1)))+(((1.472768)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1)*(((0.3127368)+x793))))+(((1.472768)*htj1))+(((htj1*htj1*htj1*htj1)*(((0.1893432)+x793))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.0219832)+x792))))+x792);
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x794=(cj1*cj4);
IkReal x795=(cj4*sj1);
IkReal x796=(cj1*sj4*sj5);
IkReal x797=(sj1*sj4*sj5);
IkReal x798=(cj5*r20);
IkReal x799=((1.0)*cj1*sj4);
IkReal x800=(cj5*r00);
if( IKabs((((r01*x797))+((r02*x795))+((r22*x794))+(((-1.0)*sj1*sj4*x800))+(((-1.0)*x798*x799))+((r21*x796)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r22*x795))+((sj1*sj4*x798))+((r02*x794))+(((-1.0)*r21*x797))+((r01*x796))+(((-1.0)*x799*x800)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*x797))+((r02*x795))+((r22*x794))+(((-1.0)*sj1*sj4*x800))+(((-1.0)*x798*x799))+((r21*x796))))+IKsqr(((((-1.0)*r22*x795))+((sj1*sj4*x798))+((r02*x794))+(((-1.0)*r21*x797))+((r01*x796))+(((-1.0)*x799*x800))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r01*x797))+((r02*x795))+((r22*x794))+(((-1.0)*sj1*sj4*x800))+(((-1.0)*x798*x799))+((r21*x796))), ((((-1.0)*r22*x795))+((sj1*sj4*x798))+((r02*x794))+(((-1.0)*r21*x797))+((r01*x796))+(((-1.0)*x799*x800))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x801=IKcos(j2);
IkReal x802=(cj1*x801);
IkReal x803=IKsin(j2);
IkReal x804=(sj1*x803);
IkReal x805=(x802+x804);
IkReal x806=((1.0)*cj4);
IkReal x807=(cj5*sj4);
IkReal x808=((1.0)*sj4*sj5);
IkReal x809=(cj1*x803);
IkReal x810=(sj1*x801);
IkReal x811=(cj5*sj3);
IkReal x812=(sj3*sj5);
IkReal x813=((1.0)*cj3*sj4);
IkReal x814=(cj3*cj4*sj5);
IkReal x815=((1.0)*cj3*cj4*cj5);
IkReal x816=((0.00325)*cj5);
IkReal x817=((0.00325)*sj5);
evalcond[0]=(((r00*x807))+(((-1.0)*r01*x808))+x805+(((-1.0)*r02*x806)));
evalcond[1]=((((-1.0)*x810))+x809+(((-1.0)*r21*x808))+(((-1.0)*r22*x806))+((r20*x807)));
evalcond[2]=((((-1.0)*r22*x813))+((r20*x812))+((r21*x814))+x805+((r21*x811))+(((-1.0)*r20*x815)));
evalcond[3]=((((-1.0)*r00*x815))+((r00*x812))+(((-1.0)*r02*x813))+((r01*x814))+((r01*x811))+(((-1.0)*x809))+x810);
evalcond[4]=((((-1.0)*(1.0)*pz))+(((-0.4184)*x810))+(((0.4184)*x809))+(((0.44)*cj1))+((r21*x816))+(((0.035055)*x804))+(((0.035055)*x802))+((r20*x817)));
evalcond[5]=((0.05)+(((-1.0)*(1.0)*px))+(((-0.035055)*x809))+(((0.4184)*x804))+(((0.44)*sj1))+(((0.035055)*x810))+((r00*x817))+((r01*x816))+(((0.4184)*x802)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x818=((1.0)*cj4);
IkReal x819=((1.0)*sj5);
CheckValue<IkReal> x820 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x819))+(((-1.0)*(1.0)*cj5*r01)))),IkReal(((((-1.0)*r01*sj5*x818))+((cj4*cj5*r00))+((r02*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x820.valid){
continue;
}
CheckValue<IkReal> x821=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*sj4*x819))+((cj5*r20*sj4))+(((-1.0)*r22*x818)))),-1);
if(!x821.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x820.value)+(((1.5707963267949)*(x821.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x822=IKsin(j3);
IkReal x823=(cj5*r11);
IkReal x824=(r10*sj5);
IkReal x825=IKcos(j3);
IkReal x826=((1.0)*x825);
IkReal x827=((1.0)*cj5*x825);
IkReal x828=((1.0)*sj5*x825);
IkReal x829=((1.0)*sj4*x822);
IkReal x830=(cj4*sj5*x822);
IkReal x831=((1.0)*cj4*cj5*x822);
evalcond[0]=((((-1.0)*r12*sj4*x826))+((x822*x824))+((x822*x823))+(((-1.0)*cj4*r10*x827))+((cj4*r11*sj5*x825)));
evalcond[1]=((((-1.0)*r20*x831))+((r21*x830))+(((-1.0)*r22*x829))+(((-1.0)*r20*x828))+(((-1.0)*r21*x827)));
evalcond[2]=(((r01*x830))+(((-1.0)*r00*x828))+(((-1.0)*r01*x827))+(((-1.0)*r02*x829))+(((-1.0)*r00*x831)));
evalcond[3]=((-1.0)+((r11*x830))+(((-1.0)*r10*x831))+(((-1.0)*r12*x829))+(((-1.0)*x823*x826))+(((-1.0)*x824*x826)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x832=(cj4*r02);
IkReal x833=(cj5*r01);
IkReal x834=(cj5*r21);
IkReal x835=(r00*sj5);
IkReal x836=(r20*sj5);
IkReal x837=(cj5*r00*sj4);
IkReal x838=(r01*sj4*sj5);
IkReal x839=((((-1.0)*(0.42066)*pz))+(((-1.0)*(5.0208)*px))+(((0.001367145)*x836))+(((0.0163176)*x835))+(((2.1154489563)*x838))+(((0.001367145)*x834))+(((2.1154489563)*x832))+(((-2.1154489563)*x837))+(((0.0163176)*x833)));
IkReal x840=(cj4*r22);
IkReal x841=(cj5*r20*sj4);
IkReal x842=(r21*sj4*sj5);
IkReal x843=((((0.42066)*x832))+(((0.42066)*x838))+(((-1.0)*(12.0)*pz))+(((5.0208)*x842))+(((5.0208)*x840))+(((0.039)*x834))+(((-5.0208)*x841))+(((-0.42066)*x837))+(((0.039)*x836)));
j1eval[0]=((5.891072)+(IKabs(((0.1893432)+x839)))+(IKabs(((0.0219832)+(((0.7051496521)*x832))+(((0.7051496521)*x838))+(((0.000455715)*x836))+(((-1.0)*(0.14022)*pz))+(((-0.7051496521)*x837))+(((0.0054392)*x833))+(((-1.0)*(1.6736)*px))+(((0.0054392)*x835))+(((0.000455715)*x834)))))+(IKabs(((-1.76)+x843)))+(IKabs(((1.76)+x843)))+(IKabs(((0.3127368)+x839)))+(IKabs(((-1.76)+(((0.013)*x836))+(((1.6736)*x842))+(((0.14022)*x832))+(((-1.0)*(4.0)*pz))+(((1.6736)*x840))+(((-0.14022)*x837))+(((-1.6736)*x841))+(((0.013)*x834))+(((0.14022)*x838))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x844=(cj4*r02);
IkReal x845=(cj4*r22);
IkReal x846=(cj5*r21);
IkReal x847=(r20*sj5);
IkReal x848=(cj5*r00*sj4);
IkReal x849=(cj5*r20*sj4);
IkReal x850=(r01*sj4*sj5);
IkReal x851=(r21*sj4*sj5);
IkReal x852=((((1.6736)*x851))+(((0.013)*x847))+(((-1.0)*(4.0)*pz))+(((0.013)*x846))+(((0.14022)*x850))+(((-0.14022)*x848))+(((1.6736)*x845))+(((-1.6736)*x849))+(((0.14022)*x844)));
IkReal x853=((((-1.0)*(12.0)*pz))+(((0.42066)*x850))+(((0.42066)*x844))+(((5.0208)*x845))+(((0.039)*x846))+(((0.039)*x847))+(((-5.0208)*x849))+(((5.0208)*x851))+(((-0.42066)*x848)));
op[0]=((-1.76)+x852);
op[1]=0;
op[2]=((-1.76)+x853);
op[3]=0;
op[4]=((1.76)+x853);
op[5]=0;
op[6]=((1.76)+x852);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x854=(cj4*r02);
IkReal x855=(cj5*r01);
IkReal x856=(cj5*r21);
IkReal x857=(r00*sj5);
IkReal x858=(r20*sj5);
IkReal x859=(cj5*r00*sj4);
IkReal x860=(r01*sj4*sj5);
IkReal x861=((((-0.7051496521)*x859))+(((0.000455715)*x858))+(((-1.0)*(0.14022)*pz))+(((0.000455715)*x856))+(((0.0054392)*x855))+(((0.7051496521)*x860))+(((0.0054392)*x857))+(((-1.0)*(1.6736)*px))+(((0.7051496521)*x854)));
IkReal x862=((((0.0163176)*x857))+(((-1.0)*(0.42066)*pz))+(((0.001367145)*x858))+(((0.0163176)*x855))+(((-1.0)*(5.0208)*px))+(((-2.1154489563)*x859))+(((2.1154489563)*x860))+(((2.1154489563)*x854))+(((0.001367145)*x856)));
j1evalpoly[0]=((0.1453768)+(((2.945536)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.1893432)+x862))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.0219832)+x861))))+(((1.472768)*(htj1*htj1*htj1*htj1*htj1)))+x861+(((1.472768)*htj1))+(((htj1*htj1)*(((0.3127368)+x862)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x863=(cj1*cj4);
IkReal x864=(cj4*sj1);
IkReal x865=(cj1*sj4*sj5);
IkReal x866=(sj1*sj4*sj5);
IkReal x867=(cj5*r20);
IkReal x868=((1.0)*cj1*sj4);
IkReal x869=(cj5*r00);
if( IKabs(((((-1.0)*sj1*sj4*x869))+((r22*x863))+((r02*x864))+((r01*x866))+(((-1.0)*x867*x868))+((r21*x865)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r22*x864))+((sj1*sj4*x867))+(((-1.0)*x868*x869))+((r01*x865))+((r02*x863))+(((-1.0)*r21*x866)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*sj4*x869))+((r22*x863))+((r02*x864))+((r01*x866))+(((-1.0)*x867*x868))+((r21*x865))))+IKsqr(((((-1.0)*r22*x864))+((sj1*sj4*x867))+(((-1.0)*x868*x869))+((r01*x865))+((r02*x863))+(((-1.0)*r21*x866))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*sj1*sj4*x869))+((r22*x863))+((r02*x864))+((r01*x866))+(((-1.0)*x867*x868))+((r21*x865))), ((((-1.0)*r22*x864))+((sj1*sj4*x867))+(((-1.0)*x868*x869))+((r01*x865))+((r02*x863))+(((-1.0)*r21*x866))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x870=IKcos(j2);
IkReal x871=(cj1*x870);
IkReal x872=IKsin(j2);
IkReal x873=(sj1*x872);
IkReal x874=(x873+x871);
IkReal x875=((1.0)*cj4);
IkReal x876=(cj5*sj4);
IkReal x877=((1.0)*sj4*sj5);
IkReal x878=(cj1*x872);
IkReal x879=(sj1*x870);
IkReal x880=(cj5*sj3);
IkReal x881=(sj3*sj5);
IkReal x882=((1.0)*cj3*sj4);
IkReal x883=(cj3*cj4*sj5);
IkReal x884=((1.0)*cj3*cj4*cj5);
IkReal x885=((0.00325)*cj5);
IkReal x886=((0.00325)*sj5);
evalcond[0]=((((-1.0)*r01*x877))+(((-1.0)*r02*x875))+x874+((r00*x876)));
evalcond[1]=(((r20*x876))+(((-1.0)*r21*x877))+(((-1.0)*r22*x875))+x878+(((-1.0)*x879)));
evalcond[2]=(((r20*x881))+((r21*x883))+(((-1.0)*r20*x884))+((r21*x880))+x874+(((-1.0)*r22*x882)));
evalcond[3]=((((-1.0)*r00*x884))+((r01*x883))+(((-1.0)*r02*x882))+((r01*x880))+((r00*x881))+(((-1.0)*x878))+x879);
evalcond[4]=((((0.035055)*x871))+(((-1.0)*(1.0)*pz))+(((0.44)*cj1))+(((0.4184)*x878))+((r20*x886))+(((-0.4184)*x879))+((r21*x885))+(((0.035055)*x873)));
evalcond[5]=((0.05)+(((-1.0)*(1.0)*px))+(((0.44)*sj1))+((r00*x886))+(((0.035055)*x879))+(((-0.035055)*x878))+(((0.4184)*x873))+((r01*x885))+(((0.4184)*x871)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x887=((1.0)*r21);
CheckValue<IkReal> x888 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*x887))+(((-1.0)*(1.0)*r20*sj5)))),IkReal((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*sj5*x887)))),IKFAST_ATAN2_MAGTHRESH);
if(!x888.valid){
continue;
}
CheckValue<IkReal> x889=IKPowWithIntegerCheck(IKsign((((r01*sj4*sj5))+((cj4*r02))+(((-1.0)*(1.0)*cj5*r00*sj4)))),-1);
if(!x889.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x888.value)+(((1.5707963267949)*(x889.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x890=IKsin(j3);
IkReal x891=(cj5*r11);
IkReal x892=(r10*sj5);
IkReal x893=IKcos(j3);
IkReal x894=((1.0)*x893);
IkReal x895=((1.0)*cj5*x893);
IkReal x896=((1.0)*sj5*x893);
IkReal x897=((1.0)*sj4*x890);
IkReal x898=(cj4*sj5*x890);
IkReal x899=((1.0)*cj4*cj5*x890);
evalcond[0]=(((x890*x891))+(((-1.0)*cj4*r10*x895))+((cj4*r11*sj5*x893))+((x890*x892))+(((-1.0)*r12*sj4*x894)));
evalcond[1]=((((-1.0)*r20*x896))+((r21*x898))+(((-1.0)*r22*x897))+(((-1.0)*r21*x895))+(((-1.0)*r20*x899)));
evalcond[2]=((((-1.0)*r02*x897))+((r01*x898))+(((-1.0)*r01*x895))+(((-1.0)*r00*x896))+(((-1.0)*r00*x899)));
evalcond[3]=((-1.0)+((r11*x898))+(((-1.0)*x891*x894))+(((-1.0)*x892*x894))+(((-1.0)*r10*x899))+(((-1.0)*r12*x897)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x900=(cj4*r02);
IkReal x901=(cj5*r01);
IkReal x902=(cj5*r21);
IkReal x903=(r00*sj5);
IkReal x904=(r20*sj5);
IkReal x905=(cj5*r00*sj4);
IkReal x906=(r01*sj4*sj5);
IkReal x907=((((2.1154489563)*x900))+(((-1.0)*(0.42066)*pz))+(((-2.1154489563)*x905))+(((-1.0)*(5.0208)*px))+(((2.1154489563)*x906))+(((0.0163176)*x901))+(((0.001367145)*x902))+(((0.001367145)*x904))+(((0.0163176)*x903)));
IkReal x908=(cj4*r22);
IkReal x909=(cj5*r20*sj4);
IkReal x910=(r21*sj4*sj5);
IkReal x911=((((-1.0)*(12.0)*pz))+(((0.039)*x904))+(((5.0208)*x908))+(((0.039)*x902))+(((0.42066)*x906))+(((-0.42066)*x905))+(((5.0208)*x910))+(((0.42066)*x900))+(((-5.0208)*x909)));
j1eval[0]=((5.891072)+(IKabs(((-1.76)+x911)))+(IKabs(((1.76)+x911)))+(IKabs(((0.0219832)+(((-0.7051496521)*x905))+(((0.000455715)*x904))+(((0.000455715)*x902))+(((0.0054392)*x901))+(((-1.0)*(0.14022)*pz))+(((0.0054392)*x903))+(((0.7051496521)*x900))+(((-1.0)*(1.6736)*px))+(((0.7051496521)*x906)))))+(IKabs(((-1.76)+(((1.6736)*x908))+(((-1.0)*(4.0)*pz))+(((-1.6736)*x909))+(((-0.14022)*x905))+(((0.013)*x904))+(((1.6736)*x910))+(((0.013)*x902))+(((0.14022)*x900))+(((0.14022)*x906)))))+(IKabs(((0.3127368)+x907)))+(IKabs(((0.1893432)+x907))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x912=(cj4*r02);
IkReal x913=(cj4*r22);
IkReal x914=(cj5*r21);
IkReal x915=(r20*sj5);
IkReal x916=(cj5*r00*sj4);
IkReal x917=(cj5*r20*sj4);
IkReal x918=(r01*sj4*sj5);
IkReal x919=(r21*sj4*sj5);
IkReal x920=((((-1.6736)*x917))+(((1.6736)*x919))+(((0.013)*x914))+(((-1.0)*(4.0)*pz))+(((1.6736)*x913))+(((0.013)*x915))+(((0.14022)*x918))+(((-0.14022)*x916))+(((0.14022)*x912)));
IkReal x921=((((-0.42066)*x916))+(((-1.0)*(12.0)*pz))+(((-5.0208)*x917))+(((0.039)*x914))+(((5.0208)*x919))+(((0.42066)*x912))+(((0.42066)*x918))+(((5.0208)*x913))+(((0.039)*x915)));
op[0]=((-1.76)+x920);
op[1]=0;
op[2]=((-1.76)+x921);
op[3]=0;
op[4]=((1.76)+x921);
op[5]=0;
op[6]=((1.76)+x920);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x922=(cj4*r02);
IkReal x923=(cj5*r01);
IkReal x924=(cj5*r21);
IkReal x925=(r00*sj5);
IkReal x926=(r20*sj5);
IkReal x927=(cj5*r00*sj4);
IkReal x928=(r01*sj4*sj5);
IkReal x929=((((0.000455715)*x926))+(((-0.7051496521)*x927))+(((-1.0)*(0.14022)*pz))+(((0.0054392)*x925))+(((0.7051496521)*x928))+(((0.7051496521)*x922))+(((0.000455715)*x924))+(((0.0054392)*x923))+(((-1.0)*(1.6736)*px)));
IkReal x930=((((-1.0)*(0.42066)*pz))+(((-1.0)*(5.0208)*px))+(((0.0163176)*x925))+(((0.001367145)*x926))+(((2.1154489563)*x928))+(((0.0163176)*x923))+(((-2.1154489563)*x927))+(((0.001367145)*x924))+(((2.1154489563)*x922)));
j1evalpoly[0]=((0.1453768)+(((2.945536)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.0219832)+x929))))+(((1.472768)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.1893432)+x930))))+(((1.472768)*htj1))+x929+(((htj1*htj1)*(((0.3127368)+x930)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x931=(cj1*cj4);
IkReal x932=(cj4*sj1);
IkReal x933=(cj1*sj4*sj5);
IkReal x934=(sj1*sj4*sj5);
IkReal x935=(cj5*r20);
IkReal x936=((1.0)*cj1*sj4);
IkReal x937=(cj5*r00);
if( IKabs((((r21*x933))+(((-1.0)*sj1*sj4*x937))+((r22*x931))+((r02*x932))+(((-1.0)*x935*x936))+((r01*x934)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r21*x934))+(((-1.0)*r22*x932))+((r01*x933))+((r02*x931))+(((-1.0)*x936*x937))+((sj1*sj4*x935)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r21*x933))+(((-1.0)*sj1*sj4*x937))+((r22*x931))+((r02*x932))+(((-1.0)*x935*x936))+((r01*x934))))+IKsqr(((((-1.0)*r21*x934))+(((-1.0)*r22*x932))+((r01*x933))+((r02*x931))+(((-1.0)*x936*x937))+((sj1*sj4*x935))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r21*x933))+(((-1.0)*sj1*sj4*x937))+((r22*x931))+((r02*x932))+(((-1.0)*x935*x936))+((r01*x934))), ((((-1.0)*r21*x934))+(((-1.0)*r22*x932))+((r01*x933))+((r02*x931))+(((-1.0)*x936*x937))+((sj1*sj4*x935))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x938=IKcos(j2);
IkReal x939=(cj1*x938);
IkReal x940=IKsin(j2);
IkReal x941=(sj1*x940);
IkReal x942=(x939+x941);
IkReal x943=((1.0)*cj4);
IkReal x944=(cj5*sj4);
IkReal x945=((1.0)*sj4*sj5);
IkReal x946=(cj1*x940);
IkReal x947=(sj1*x938);
IkReal x948=(cj5*sj3);
IkReal x949=(sj3*sj5);
IkReal x950=((1.0)*cj3*sj4);
IkReal x951=(cj3*cj4*sj5);
IkReal x952=((1.0)*cj3*cj4*cj5);
IkReal x953=((0.00325)*cj5);
IkReal x954=((0.00325)*sj5);
evalcond[0]=(((r00*x944))+(((-1.0)*r01*x945))+(((-1.0)*r02*x943))+x942);
evalcond[1]=((((-1.0)*r21*x945))+(((-1.0)*r22*x943))+((r20*x944))+(((-1.0)*x947))+x946);
evalcond[2]=((((-1.0)*r22*x950))+((r21*x951))+(((-1.0)*r20*x952))+((r20*x949))+((r21*x948))+x942);
evalcond[3]=((((-1.0)*r02*x950))+((r00*x949))+(((-1.0)*x946))+(((-1.0)*r00*x952))+((r01*x951))+((r01*x948))+x947);
evalcond[4]=((((-1.0)*(1.0)*pz))+((r21*x953))+(((0.44)*cj1))+((r20*x954))+(((0.035055)*x941))+(((0.035055)*x939))+(((0.4184)*x946))+(((-0.4184)*x947)));
evalcond[5]=((0.05)+(((-1.0)*(1.0)*px))+(((0.035055)*x947))+(((0.44)*sj1))+(((0.4184)*x939))+((r00*x954))+(((0.4184)*x941))+(((-0.035055)*x946))+((r01*x953)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x955=((1.0)*sj4);
IkReal x956=(((r01*sj4*sj5))+((cj4*r02))+(((-1.0)*cj5*r00*x955)));
j3eval[0]=x956;
j3eval[1]=((IKabs((((r20*sj5))+((cj5*r21)))))+(IKabs((((cj4*r21*sj5))+(((-1.0)*(1.0)*cj4*cj5*r20))+(((-1.0)*r22*x955))))));
j3eval[2]=IKsign(x956);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x957=((1.0)*cj4);
IkReal x958=((1.0)*sj4);
IkReal x959=((((-1.0)*r22*x957))+((cj5*r20*sj4))+(((-1.0)*r21*sj5*x958)));
j3eval[0]=x959;
j3eval[1]=((IKabs((((cj5*r01))+((r00*sj5)))))+(IKabs((((cj4*r01*sj5))+(((-1.0)*r02*x958))+(((-1.0)*cj5*r00*x957))))));
j3eval[2]=IKsign(x959);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x960=r10*r10;
IkReal x961=r12*r12;
IkReal x962=(r10*sj5);
IkReal x963=((2.0)*cj5*r11*x962);
IkReal x964=cj4*cj4;
IkReal x965=r11*r11;
IkReal x966=(x964*x965);
IkReal x967=cj5*cj5;
IkReal x968=((2.0)*r12*sj4);
IkReal x969=(cj4*cj5*r10);
IkReal x970=(cj4*r11*sj5);
IkReal x971=(x960*x967);
IkReal x972=(((x968*x969))+(((-1.0)*x971))+(((-1.0)*x966*x967))+(((-1.0)*x968*x970))+(((-1.0)*x961*x964))+((x964*x971))+(((-1.0)*x963*x964))+x966+x960+x961+x963+((x965*x967)));
j3eval[0]=x972;
j3eval[1]=((IKabs((x962+((cj5*r11)))))+(IKabs((((r12*sj4))+(((-1.0)*x970))+x969))));
j3eval[2]=IKsign(x972);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x973=(cj4*cj5*r10);
IkReal x974=(cj4*r11*sj5);
IkReal x975=(r10*sj5);
IkReal x976=r10*r10;
IkReal x977=r12*r12;
IkReal x978=((2.0)*cj5*r11*x975);
IkReal x979=cj4*cj4;
IkReal x980=r11*r11;
IkReal x981=(x979*x980);
IkReal x982=cj5*cj5;
IkReal x983=((2.0)*r12*sj4);
IkReal x984=(x976*x982);
CheckValue<IkReal> x985 = IKatan2WithCheck(IkReal((((r12*sj4))+(((-1.0)*x974))+x973)),IkReal((x975+((cj5*r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x985.valid){
continue;
}
CheckValue<IkReal> x986=IKPowWithIntegerCheck(IKsign((((x973*x983))+(((-1.0)*x977*x979))+(((-1.0)*x974*x983))+(((-1.0)*x978*x979))+(((-1.0)*x981*x982))+x981+x977+x976+x978+((x979*x984))+(((-1.0)*x984))+((x980*x982)))),-1);
if(!x986.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x985.value)+(((1.5707963267949)*(x986.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x987=IKsin(j3);
IkReal x988=(cj5*r11);
IkReal x989=(r10*sj5);
IkReal x990=IKcos(j3);
IkReal x991=((1.0)*x990);
IkReal x992=((1.0)*cj5*x990);
IkReal x993=((1.0)*sj5*x990);
IkReal x994=((1.0)*sj4*x987);
IkReal x995=(cj4*sj5*x987);
IkReal x996=((1.0)*cj4*cj5*x987);
evalcond[0]=(((x987*x989))+(((-1.0)*r12*sj4*x991))+(((-1.0)*cj4*r10*x992))+((cj4*r11*sj5*x990))+((x987*x988)));
evalcond[1]=((((-1.0)*r22*x994))+(((-1.0)*r20*x996))+((r21*x995))+(((-1.0)*r20*x993))+(((-1.0)*r21*x992)));
evalcond[2]=(((r01*x995))+(((-1.0)*r01*x992))+(((-1.0)*r00*x996))+(((-1.0)*r00*x993))+(((-1.0)*r02*x994)));
evalcond[3]=((1.0)+((r11*x995))+(((-1.0)*x989*x991))+(((-1.0)*r12*x994))+(((-1.0)*r10*x996))+(((-1.0)*x988*x991)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x997=(cj4*r22);
IkReal x998=(cj5*r20*sj4);
IkReal x999=(r21*sj4*sj5);
IkReal x1000=(cj5*r21);
IkReal x1001=(r20*sj5);
IkReal x1002=(cj3*r22*sj4);
IkReal x1003=(cj5*r21*sj3);
IkReal x1004=(r20*sj3*sj5);
IkReal x1005=(cj3*cj4*cj5*r20);
IkReal x1006=(cj3*cj4*r21*sj5);
IkReal x1007=((-1.76)+(((0.013)*x1001))+(((-1.0)*(4.0)*pz))+(((0.14022)*x1002))+(((-0.14022)*x1003))+(((0.14022)*x1005))+(((-0.14022)*x1004))+(((-0.14022)*x1006))+(((0.013)*x1000)));
IkReal x1008=((-1.0)*(((12.0)*pz)));
IkReal x1009=((0.039)*x1000);
IkReal x1010=((0.039)*x1001);
IkReal x1011=((0.42066)*x1002);
IkReal x1012=((-0.42066)*x1003);
IkReal x1013=((-0.42066)*x1004);
IkReal x1014=((0.42066)*x1005);
IkReal x1015=((-0.42066)*x1006);
IkReal x1016=((((5.0208)*x999))+(((5.0208)*x997))+(((-5.0208)*x998))+x1013+x1015+x1014+x1011+x1012+x1010+x1008+x1009);
IkReal x1017=(cj3*r02*sj4);
IkReal x1018=(cj5*r01*sj3);
IkReal x1019=(r00*sj3*sj5);
IkReal x1020=(cj3*cj4*cj5*r00);
IkReal x1021=(cj3*cj4*r01*sj5);
IkReal x1022=((((-5.0208)*x1019))+(((-5.0208)*x1021))+x1013+x1015+x1014+x1011+x1012+x1010+x1008+x1009+(((-5.0208)*x1018))+(((5.0208)*x1017))+(((5.0208)*x1020)));
j1eval[0]=((IKabs(((((-1.6736)*x1019))+(((-1.6736)*x1021))+(((-1.6736)*x1018))+(((1.6736)*x1017))+(((1.6736)*x1020))+x1007)))+(IKabs(((-1.76)+x1022)))+(IKabs(((1.76)+x1022)))+(IKabs(((-1.76)+x1016)))+(IKabs(((1.76)+x1016)))+(IKabs((x1007+(((1.6736)*x999))+(((1.6736)*x997))+(((-1.6736)*x998))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1023=(cj4*r22);
IkReal x1024=(cj5*r21);
IkReal x1025=(r20*sj5);
IkReal x1026=(cj3*r22*sj4);
IkReal x1027=(cj5*r20*sj4);
IkReal x1028=(cj5*r21*sj3);
IkReal x1029=(r20*sj3*sj5);
IkReal x1030=(r21*sj4*sj5);
IkReal x1031=(cj3*cj4*cj5*r20);
IkReal x1032=(cj3*cj4*r21*sj5);
IkReal x1033=((((1.6736)*x1030))+(((1.6736)*x1023))+(((-0.14022)*x1028))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x1029))+(((0.013)*x1024))+(((0.013)*x1025))+(((0.14022)*x1031))+(((0.14022)*x1026))+(((-1.6736)*x1027))+(((-0.14022)*x1032)));
IkReal x1034=((((-5.0208)*x1027))+(((0.42066)*x1031))+(((-1.0)*(12.0)*pz))+(((0.039)*x1024))+(((0.42066)*x1026))+(((-0.42066)*x1029))+(((-0.42066)*x1032))+(((0.039)*x1025))+(((5.0208)*x1030))+(((-0.42066)*x1028))+(((5.0208)*x1023)));
op[0]=((-1.76)+x1033);
op[1]=0;
op[2]=((-1.76)+x1034);
op[3]=0;
op[4]=((1.76)+x1034);
op[5]=0;
op[6]=((1.76)+x1033);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1035=(cj5*r21);
IkReal x1036=(r20*sj5);
IkReal x1037=(cj3*r02*sj4);
IkReal x1038=(cj3*r22*sj4);
IkReal x1039=(cj5*r01*sj3);
IkReal x1040=(cj5*r21*sj3);
IkReal x1041=(r00*sj3*sj5);
IkReal x1042=(r20*sj3*sj5);
IkReal x1043=(cj3*cj4*cj5*r00);
IkReal x1044=x1031;
IkReal x1045=(cj3*cj4*r01*sj5);
IkReal x1046=x1032;
IkReal x1047=((((-1.6736)*x1039))+(((1.6736)*x1037))+(((-0.14022)*x1046))+(((-1.6736)*x1045))+(((-1.0)*(4.0)*pz))+(((0.14022)*x1044))+(((1.6736)*x1043))+(((0.013)*x1035))+(((-0.14022)*x1042))+(((0.013)*x1036))+(((-0.14022)*x1040))+(((0.14022)*x1038))+(((-1.6736)*x1041)));
IkReal x1048=((((0.039)*x1036))+(((-1.0)*(12.0)*pz))+(((-0.42066)*x1040))+(((0.42066)*x1038))+(((-0.42066)*x1046))+(((0.42066)*x1044))+(((-5.0208)*x1039))+(((-5.0208)*x1041))+(((0.039)*x1035))+(((-0.42066)*x1042))+(((5.0208)*x1037))+(((5.0208)*x1043))+(((-5.0208)*x1045)));
j1evalpoly[0]=((1.76)+x1047+(((htj1*htj1)*(((1.76)+x1048))))+(((htj1*htj1*htj1*htj1)*(((-1.76)+x1048))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.76)+x1047)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1049=(cj1*cj4);
IkReal x1050=((1.0)*r02);
IkReal x1051=(cj4*sj1);
IkReal x1052=(cj1*sj4*sj5);
IkReal x1053=(cj5*r00);
IkReal x1054=(sj1*sj4);
IkReal x1055=(cj5*r20);
IkReal x1056=((1.0)*r01);
IkReal x1057=(sj1*sj4*sj5);
if( IKabs(((((-1.0)*cj1*sj4*x1055))+(((-1.0)*x1050*x1051))+(((-1.0)*x1056*x1057))+((x1053*x1054))+((r22*x1049))+((r21*x1052)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1049*x1050))+((cj1*sj4*x1053))+(((-1.0)*r21*x1057))+(((-1.0)*x1052*x1056))+(((-1.0)*r22*x1051))+((x1054*x1055)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*sj4*x1055))+(((-1.0)*x1050*x1051))+(((-1.0)*x1056*x1057))+((x1053*x1054))+((r22*x1049))+((r21*x1052))))+IKsqr(((((-1.0)*x1049*x1050))+((cj1*sj4*x1053))+(((-1.0)*r21*x1057))+(((-1.0)*x1052*x1056))+(((-1.0)*r22*x1051))+((x1054*x1055))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj1*sj4*x1055))+(((-1.0)*x1050*x1051))+(((-1.0)*x1056*x1057))+((x1053*x1054))+((r22*x1049))+((r21*x1052))), ((((-1.0)*x1049*x1050))+((cj1*sj4*x1053))+(((-1.0)*r21*x1057))+(((-1.0)*x1052*x1056))+(((-1.0)*r22*x1051))+((x1054*x1055))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1058=IKsin(j2);
IkReal x1059=(cj1*x1058);
IkReal x1060=IKcos(j2);
IkReal x1061=(sj1*x1060);
IkReal x1062=(x1059+(((-1.0)*x1061)));
IkReal x1063=((1.0)*cj4);
IkReal x1064=(cj5*sj4);
IkReal x1065=((1.0)*sj4*sj5);
IkReal x1066=(cj1*x1060);
IkReal x1067=(sj1*x1058);
IkReal x1068=(cj5*sj3);
IkReal x1069=(sj3*sj5);
IkReal x1070=((1.0)*cj3*sj4);
IkReal x1071=(cj3*cj4*sj5);
IkReal x1072=((1.0)*cj3*cj4*cj5);
IkReal x1073=((0.00325)*cj5);
IkReal x1074=((0.00325)*sj5);
evalcond[0]=(x1062+((r20*x1064))+(((-1.0)*r21*x1065))+(((-1.0)*r22*x1063)));
evalcond[1]=((((-1.0)*x1067))+(((-1.0)*x1066))+(((-1.0)*r02*x1063))+((r00*x1064))+(((-1.0)*r01*x1065)));
evalcond[2]=(((r21*x1071))+x1067+x1066+(((-1.0)*r22*x1070))+((r20*x1069))+((r21*x1068))+(((-1.0)*r20*x1072)));
evalcond[3]=(x1062+((r01*x1071))+(((-1.0)*r00*x1072))+((r01*x1068))+(((-1.0)*r02*x1070))+((r00*x1069)));
evalcond[4]=((((0.4184)*x1059))+(((-0.4184)*x1061))+(((-1.0)*(1.0)*pz))+(((0.035055)*x1066))+((r21*x1073))+(((0.44)*cj1))+(((0.035055)*x1067))+((r20*x1074)));
evalcond[5]=((-0.05)+((r00*x1074))+(((-1.0)*(1.0)*px))+(((-1.0)*(0.44)*sj1))+(((-0.4184)*x1067))+(((-0.4184)*x1066))+(((-0.035055)*x1061))+((r01*x1073))+(((0.035055)*x1059)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1075=((1.0)*cj4);
IkReal x1076=((1.0)*sj4);
CheckValue<IkReal> x1077=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*sj5*x1076))+((cj5*r20*sj4))+(((-1.0)*r22*x1075)))),-1);
if(!x1077.valid){
continue;
}
CheckValue<IkReal> x1078 = IKatan2WithCheck(IkReal((((cj5*r01))+((r00*sj5)))),IkReal(((((-1.0)*r02*x1076))+((cj4*r01*sj5))+(((-1.0)*cj5*r00*x1075)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1078.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1077.value)))+(x1078.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1079=IKsin(j3);
IkReal x1080=(cj5*r11);
IkReal x1081=(r10*sj5);
IkReal x1082=IKcos(j3);
IkReal x1083=((1.0)*x1082);
IkReal x1084=((1.0)*cj5*x1082);
IkReal x1085=((1.0)*sj5*x1082);
IkReal x1086=((1.0)*sj4*x1079);
IkReal x1087=(cj4*sj5*x1079);
IkReal x1088=((1.0)*cj4*cj5*x1079);
evalcond[0]=(((cj4*r11*sj5*x1082))+((x1079*x1081))+(((-1.0)*r12*sj4*x1083))+((x1079*x1080))+(((-1.0)*cj4*r10*x1084)));
evalcond[1]=((((-1.0)*r22*x1086))+(((-1.0)*r20*x1088))+(((-1.0)*r21*x1084))+(((-1.0)*r20*x1085))+((r21*x1087)));
evalcond[2]=((((-1.0)*r00*x1085))+(((-1.0)*r02*x1086))+(((-1.0)*r00*x1088))+(((-1.0)*r01*x1084))+((r01*x1087)));
evalcond[3]=((1.0)+((r11*x1087))+(((-1.0)*x1081*x1083))+(((-1.0)*r10*x1088))+(((-1.0)*x1080*x1083))+(((-1.0)*r12*x1086)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x1089=(cj4*r22);
IkReal x1090=(cj5*r20*sj4);
IkReal x1091=(r21*sj4*sj5);
IkReal x1092=(cj5*r21);
IkReal x1093=(r20*sj5);
IkReal x1094=(cj3*r22*sj4);
IkReal x1095=(cj5*r21*sj3);
IkReal x1096=(r20*sj3*sj5);
IkReal x1097=(cj3*cj4*cj5*r20);
IkReal x1098=(cj3*cj4*r21*sj5);
IkReal x1099=((-1.76)+(((0.013)*x1092))+(((0.013)*x1093))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x1098))+(((-0.14022)*x1096))+(((0.14022)*x1094))+(((-0.14022)*x1095))+(((0.14022)*x1097)));
IkReal x1100=((-1.0)*(((12.0)*pz)));
IkReal x1101=((0.039)*x1092);
IkReal x1102=((0.039)*x1093);
IkReal x1103=((0.42066)*x1094);
IkReal x1104=((-0.42066)*x1095);
IkReal x1105=((-0.42066)*x1096);
IkReal x1106=((0.42066)*x1097);
IkReal x1107=((-0.42066)*x1098);
IkReal x1108=(x1102+x1103+x1104+x1105+x1100+x1101+x1106+x1107+(((5.0208)*x1091))+(((-5.0208)*x1090))+(((5.0208)*x1089)));
IkReal x1109=(cj3*r02*sj4);
IkReal x1110=(cj5*r01*sj3);
IkReal x1111=(r00*sj3*sj5);
IkReal x1112=(cj3*cj4*cj5*r00);
IkReal x1113=(cj3*cj4*r01*sj5);
IkReal x1114=(x1102+x1103+x1104+x1105+x1100+x1101+x1106+x1107+(((-5.0208)*x1113))+(((-5.0208)*x1111))+(((5.0208)*x1109))+(((5.0208)*x1112))+(((-5.0208)*x1110)));
j1eval[0]=((IKabs(((((1.6736)*x1109))+(((-1.6736)*x1111))+(((1.6736)*x1112))+(((-1.6736)*x1113))+x1099+(((-1.6736)*x1110)))))+(IKabs(((-1.76)+x1114)))+(IKabs(((1.76)+x1108)))+(IKabs(((-1.76)+x1108)))+(IKabs(((1.76)+x1114)))+(IKabs(((((-1.6736)*x1090))+(((1.6736)*x1091))+x1099+(((1.6736)*x1089))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1115=(cj4*r22);
IkReal x1116=(cj5*r21);
IkReal x1117=(r20*sj5);
IkReal x1118=(cj3*r22*sj4);
IkReal x1119=(cj5*r20*sj4);
IkReal x1120=(cj5*r21*sj3);
IkReal x1121=(r20*sj3*sj5);
IkReal x1122=(r21*sj4*sj5);
IkReal x1123=(cj3*cj4*cj5*r20);
IkReal x1124=(cj3*cj4*r21*sj5);
IkReal x1125=((((1.6736)*x1122))+(((0.013)*x1116))+(((0.14022)*x1118))+(((-0.14022)*x1120))+(((-1.6736)*x1119))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x1121))+(((0.14022)*x1123))+(((-0.14022)*x1124))+(((0.013)*x1117))+(((1.6736)*x1115)));
IkReal x1126=((((-1.0)*(12.0)*pz))+(((-5.0208)*x1119))+(((0.42066)*x1123))+(((-0.42066)*x1121))+(((5.0208)*x1122))+(((0.42066)*x1118))+(((5.0208)*x1115))+(((-0.42066)*x1120))+(((0.039)*x1116))+(((0.039)*x1117))+(((-0.42066)*x1124)));
op[0]=((-1.76)+x1125);
op[1]=0;
op[2]=((-1.76)+x1126);
op[3]=0;
op[4]=((1.76)+x1126);
op[5]=0;
op[6]=((1.76)+x1125);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1127=(cj5*r21);
IkReal x1128=(r20*sj5);
IkReal x1129=(cj3*r02*sj4);
IkReal x1130=(cj3*r22*sj4);
IkReal x1131=(cj5*r01*sj3);
IkReal x1132=(cj5*r21*sj3);
IkReal x1133=(r00*sj3*sj5);
IkReal x1134=(r20*sj3*sj5);
IkReal x1135=(cj3*cj4*cj5*r00);
IkReal x1136=x1123;
IkReal x1137=(cj3*cj4*r01*sj5);
IkReal x1138=x1124;
IkReal x1139=((((-1.6736)*x1131))+(((-1.0)*(4.0)*pz))+(((-0.14022)*x1132))+(((0.013)*x1127))+(((0.013)*x1128))+(((-0.14022)*x1134))+(((-1.6736)*x1133))+(((-1.6736)*x1137))+(((0.14022)*x1130))+(((1.6736)*x1129))+(((-0.14022)*x1138))+(((1.6736)*x1135))+(((0.14022)*x1136)));
IkReal x1140=((((0.039)*x1128))+(((0.039)*x1127))+(((5.0208)*x1135))+(((-1.0)*(12.0)*pz))+(((0.42066)*x1136))+(((-5.0208)*x1133))+(((-0.42066)*x1138))+(((0.42066)*x1130))+(((-0.42066)*x1132))+(((-5.0208)*x1137))+(((5.0208)*x1129))+(((-0.42066)*x1134))+(((-5.0208)*x1131)));
j1evalpoly[0]=((1.76)+(((htj1*htj1*htj1*htj1)*(((-1.76)+x1140))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.76)+x1139))))+x1139+(((htj1*htj1)*(((1.76)+x1140)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1141=(cj1*cj4);
IkReal x1142=((1.0)*r02);
IkReal x1143=(cj4*sj1);
IkReal x1144=(cj1*sj4*sj5);
IkReal x1145=(cj5*r00);
IkReal x1146=(sj1*sj4);
IkReal x1147=(cj5*r20);
IkReal x1148=((1.0)*r01);
IkReal x1149=(sj1*sj4*sj5);
if( IKabs((((r22*x1141))+((r21*x1144))+(((-1.0)*x1148*x1149))+(((-1.0)*x1142*x1143))+(((-1.0)*cj1*sj4*x1147))+((x1145*x1146)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1141*x1142))+(((-1.0)*r22*x1143))+(((-1.0)*x1144*x1148))+((cj1*sj4*x1145))+(((-1.0)*r21*x1149))+((x1146*x1147)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r22*x1141))+((r21*x1144))+(((-1.0)*x1148*x1149))+(((-1.0)*x1142*x1143))+(((-1.0)*cj1*sj4*x1147))+((x1145*x1146))))+IKsqr(((((-1.0)*x1141*x1142))+(((-1.0)*r22*x1143))+(((-1.0)*x1144*x1148))+((cj1*sj4*x1145))+(((-1.0)*r21*x1149))+((x1146*x1147))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r22*x1141))+((r21*x1144))+(((-1.0)*x1148*x1149))+(((-1.0)*x1142*x1143))+(((-1.0)*cj1*sj4*x1147))+((x1145*x1146))), ((((-1.0)*x1141*x1142))+(((-1.0)*r22*x1143))+(((-1.0)*x1144*x1148))+((cj1*sj4*x1145))+(((-1.0)*r21*x1149))+((x1146*x1147))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1150=IKsin(j2);
IkReal x1151=(cj1*x1150);
IkReal x1152=IKcos(j2);
IkReal x1153=(sj1*x1152);
IkReal x1154=(x1151+(((-1.0)*x1153)));
IkReal x1155=((1.0)*cj4);
IkReal x1156=(cj5*sj4);
IkReal x1157=((1.0)*sj4*sj5);
IkReal x1158=(cj1*x1152);
IkReal x1159=(sj1*x1150);
IkReal x1160=(cj5*sj3);
IkReal x1161=(sj3*sj5);
IkReal x1162=((1.0)*cj3*sj4);
IkReal x1163=(cj3*cj4*sj5);
IkReal x1164=((1.0)*cj3*cj4*cj5);
IkReal x1165=((0.00325)*cj5);
IkReal x1166=((0.00325)*sj5);
evalcond[0]=(x1154+(((-1.0)*r21*x1157))+((r20*x1156))+(((-1.0)*r22*x1155)));
evalcond[1]=((((-1.0)*r02*x1155))+(((-1.0)*r01*x1157))+(((-1.0)*x1158))+((r00*x1156))+(((-1.0)*x1159)));
evalcond[2]=(((r21*x1163))+x1158+x1159+(((-1.0)*r22*x1162))+((r20*x1161))+((r21*x1160))+(((-1.0)*r20*x1164)));
evalcond[3]=(x1154+(((-1.0)*r00*x1164))+((r01*x1163))+(((-1.0)*r02*x1162))+((r01*x1160))+((r00*x1161)));
evalcond[4]=((((-0.4184)*x1153))+(((-1.0)*(1.0)*pz))+(((0.4184)*x1151))+(((0.44)*cj1))+(((0.035055)*x1159))+(((0.035055)*x1158))+((r21*x1165))+((r20*x1166)));
evalcond[5]=((-0.05)+(((-0.4184)*x1159))+(((-1.0)*(1.0)*px))+(((-1.0)*(0.44)*sj1))+(((0.035055)*x1151))+((r01*x1165))+(((-0.035055)*x1153))+(((-0.4184)*x1158))+((r00*x1166)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1167=((1.0)*sj4);
CheckValue<IkReal> x1168=IKPowWithIntegerCheck(IKsign((((r01*sj4*sj5))+((cj4*r02))+(((-1.0)*cj5*r00*x1167)))),-1);
if(!x1168.valid){
continue;
}
CheckValue<IkReal> x1169 = IKatan2WithCheck(IkReal((((r20*sj5))+((cj5*r21)))),IkReal((((cj4*r21*sj5))+(((-1.0)*(1.0)*cj4*cj5*r20))+(((-1.0)*r22*x1167)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1169.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1168.value)))+(x1169.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1170=IKsin(j3);
IkReal x1171=(cj5*r11);
IkReal x1172=(r10*sj5);
IkReal x1173=IKcos(j3);
IkReal x1174=((1.0)*x1173);
IkReal x1175=((1.0)*cj5*x1173);
IkReal x1176=((1.0)*sj5*x1173);
IkReal x1177=((1.0)*sj4*x1170);
IkReal x1178=(cj4*sj5*x1170);
IkReal x1179=((1.0)*cj4*cj5*x1170);
evalcond[0]=(((x1170*x1172))+((cj4*r11*sj5*x1173))+(((-1.0)*cj4*r10*x1175))+(((-1.0)*r12*sj4*x1174))+((x1170*x1171)));
evalcond[1]=(((r21*x1178))+(((-1.0)*r20*x1176))+(((-1.0)*r20*x1179))+(((-1.0)*r21*x1175))+(((-1.0)*r22*x1177)));
evalcond[2]=((((-1.0)*r01*x1175))+((r01*x1178))+(((-1.0)*r00*x1176))+(((-1.0)*r00*x1179))+(((-1.0)*r02*x1177)));
evalcond[3]=((1.0)+(((-1.0)*x1172*x1174))+((r11*x1178))+(((-1.0)*r10*x1179))+(((-1.0)*x1171*x1174))+(((-1.0)*r12*x1177)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x1180=(cj4*r22);
IkReal x1181=(cj5*r20*sj4);
IkReal x1182=(r21*sj4*sj5);
IkReal x1183=(cj5*r21);
IkReal x1184=(r20*sj5);
IkReal x1185=(cj3*r22*sj4);
IkReal x1186=(cj5*r21*sj3);
IkReal x1187=(r20*sj3*sj5);
IkReal x1188=(cj3*cj4*cj5*r20);
IkReal x1189=(cj3*cj4*r21*sj5);
IkReal x1190=((-1.76)+(((0.14022)*x1185))+(((-0.14022)*x1189))+(((-1.0)*(4.0)*pz))+(((0.013)*x1184))+(((-0.14022)*x1186))+(((-0.14022)*x1187))+(((0.013)*x1183))+(((0.14022)*x1188)));
IkReal x1191=((-1.0)*(((12.0)*pz)));
IkReal x1192=((0.039)*x1183);
IkReal x1193=((0.039)*x1184);
IkReal x1194=((0.42066)*x1185);
IkReal x1195=((-0.42066)*x1186);
IkReal x1196=((-0.42066)*x1187);
IkReal x1197=((0.42066)*x1188);
IkReal x1198=((-0.42066)*x1189);
IkReal x1199=((((5.0208)*x1182))+(((5.0208)*x1180))+(((-5.0208)*x1181))+x1197+x1196+x1195+x1194+x1193+x1192+x1191+x1198);
IkReal x1200=(cj3*r02*sj4);
IkReal x1201=(cj5*r01*sj3);
IkReal x1202=(r00*sj3*sj5);
IkReal x1203=(cj3*cj4*cj5*r00);
IkReal x1204=(cj3*cj4*r01*sj5);
IkReal x1205=((((5.0208)*x1203))+(((5.0208)*x1200))+x1197+x1196+x1195+x1194+x1193+x1192+x1191+x1198+(((-5.0208)*x1201))+(((-5.0208)*x1204))+(((-5.0208)*x1202)));
j1eval[0]=((IKabs(((-1.76)+x1199)))+(IKabs(((((-1.6736)*x1181))+(((1.6736)*x1182))+(((1.6736)*x1180))+x1190)))+(IKabs(((1.76)+x1199)))+(IKabs(((-1.76)+x1205)))+(IKabs(((1.76)+x1205)))+(IKabs(((((-1.6736)*x1202))+(((1.6736)*x1203))+(((-1.6736)*x1204))+(((1.6736)*x1200))+x1190+(((-1.6736)*x1201))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1206=(cj4*r22);
IkReal x1207=(cj5*r21);
IkReal x1208=(r20*sj5);
IkReal x1209=(cj3*r22*sj4);
IkReal x1210=(cj5*r20*sj4);
IkReal x1211=(cj5*r21*sj3);
IkReal x1212=(r20*sj3*sj5);
IkReal x1213=(r21*sj4*sj5);
IkReal x1214=(cj3*cj4*cj5*r20);
IkReal x1215=(cj3*cj4*r21*sj5);
IkReal x1216=((((0.14022)*x1214))+(((-1.0)*(4.0)*pz))+(((0.013)*x1208))+(((1.6736)*x1206))+(((1.6736)*x1213))+(((-0.14022)*x1212))+(((-0.14022)*x1211))+(((0.013)*x1207))+(((-1.6736)*x1210))+(((-0.14022)*x1215))+(((0.14022)*x1209)));
IkReal x1217=((((-0.42066)*x1211))+(((0.42066)*x1214))+(((-1.0)*(12.0)*pz))+(((0.42066)*x1209))+(((-0.42066)*x1212))+(((-0.42066)*x1215))+(((-5.0208)*x1210))+(((0.039)*x1208))+(((5.0208)*x1206))+(((5.0208)*x1213))+(((0.039)*x1207)));
op[0]=((-1.76)+x1216);
op[1]=0;
op[2]=((-1.76)+x1217);
op[3]=0;
op[4]=((1.76)+x1217);
op[5]=0;
op[6]=((1.76)+x1216);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1218=(cj5*r21);
IkReal x1219=(r20*sj5);
IkReal x1220=(cj3*r02*sj4);
IkReal x1221=(cj3*r22*sj4);
IkReal x1222=(cj5*r01*sj3);
IkReal x1223=(cj5*r21*sj3);
IkReal x1224=(r00*sj3*sj5);
IkReal x1225=(r20*sj3*sj5);
IkReal x1226=(cj3*cj4*cj5*r00);
IkReal x1227=x1214;
IkReal x1228=(cj3*cj4*r01*sj5);
IkReal x1229=x1215;
IkReal x1230=((((-0.14022)*x1225))+(((-0.14022)*x1229))+(((-1.0)*(4.0)*pz))+(((0.013)*x1218))+(((1.6736)*x1220))+(((-1.6736)*x1222))+(((-0.14022)*x1223))+(((0.14022)*x1221))+(((1.6736)*x1226))+(((0.14022)*x1227))+(((0.013)*x1219))+(((-1.6736)*x1224))+(((-1.6736)*x1228)));
IkReal x1231=((((-0.42066)*x1223))+(((-1.0)*(12.0)*pz))+(((0.039)*x1218))+(((0.039)*x1219))+(((5.0208)*x1220))+(((-5.0208)*x1222))+(((-0.42066)*x1229))+(((5.0208)*x1226))+(((-5.0208)*x1224))+(((-5.0208)*x1228))+(((0.42066)*x1227))+(((0.42066)*x1221))+(((-0.42066)*x1225)));
j1evalpoly[0]=((1.76)+x1230+(((htj1*htj1)*(((1.76)+x1231))))+(((htj1*htj1*htj1*htj1)*(((-1.76)+x1231))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.76)+x1230)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1232=(cj1*cj4);
IkReal x1233=((1.0)*r02);
IkReal x1234=(cj4*sj1);
IkReal x1235=(cj1*sj4*sj5);
IkReal x1236=(cj5*r00);
IkReal x1237=(sj1*sj4);
IkReal x1238=(cj5*r20);
IkReal x1239=((1.0)*r01);
IkReal x1240=(sj1*sj4*sj5);
if( IKabs((((r22*x1232))+((r21*x1235))+(((-1.0)*x1239*x1240))+((x1236*x1237))+(((-1.0)*x1233*x1234))+(((-1.0)*cj1*sj4*x1238)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1235*x1239))+(((-1.0)*r21*x1240))+(((-1.0)*x1232*x1233))+((cj1*sj4*x1236))+((x1237*x1238))+(((-1.0)*r22*x1234)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r22*x1232))+((r21*x1235))+(((-1.0)*x1239*x1240))+((x1236*x1237))+(((-1.0)*x1233*x1234))+(((-1.0)*cj1*sj4*x1238))))+IKsqr(((((-1.0)*x1235*x1239))+(((-1.0)*r21*x1240))+(((-1.0)*x1232*x1233))+((cj1*sj4*x1236))+((x1237*x1238))+(((-1.0)*r22*x1234))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r22*x1232))+((r21*x1235))+(((-1.0)*x1239*x1240))+((x1236*x1237))+(((-1.0)*x1233*x1234))+(((-1.0)*cj1*sj4*x1238))), ((((-1.0)*x1235*x1239))+(((-1.0)*r21*x1240))+(((-1.0)*x1232*x1233))+((cj1*sj4*x1236))+((x1237*x1238))+(((-1.0)*r22*x1234))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1241=IKsin(j2);
IkReal x1242=(cj1*x1241);
IkReal x1243=IKcos(j2);
IkReal x1244=(sj1*x1243);
IkReal x1245=((((-1.0)*x1244))+x1242);
IkReal x1246=((1.0)*cj4);
IkReal x1247=(cj5*sj4);
IkReal x1248=((1.0)*sj4*sj5);
IkReal x1249=(cj1*x1243);
IkReal x1250=(sj1*x1241);
IkReal x1251=(cj5*sj3);
IkReal x1252=(sj3*sj5);
IkReal x1253=((1.0)*cj3*sj4);
IkReal x1254=(cj3*cj4*sj5);
IkReal x1255=((1.0)*cj3*cj4*cj5);
IkReal x1256=((0.00325)*cj5);
IkReal x1257=((0.00325)*sj5);
evalcond[0]=(((r20*x1247))+(((-1.0)*r22*x1246))+(((-1.0)*r21*x1248))+x1245);
evalcond[1]=((((-1.0)*r01*x1248))+((r00*x1247))+(((-1.0)*x1249))+(((-1.0)*x1250))+(((-1.0)*r02*x1246)));
evalcond[2]=(((r20*x1252))+((r21*x1251))+(((-1.0)*r20*x1255))+((r21*x1254))+x1250+(((-1.0)*r22*x1253))+x1249);
evalcond[3]=((((-1.0)*r00*x1255))+((r00*x1252))+(((-1.0)*r02*x1253))+((r01*x1251))+x1245+((r01*x1254)));
evalcond[4]=((((0.4184)*x1242))+(((-0.4184)*x1244))+(((0.035055)*x1250))+(((-1.0)*(1.0)*pz))+(((0.035055)*x1249))+((r20*x1257))+(((0.44)*cj1))+((r21*x1256)));
evalcond[5]=((-0.05)+(((-1.0)*(1.0)*px))+(((-1.0)*(0.44)*sj1))+((r01*x1256))+(((-0.4184)*x1249))+(((-0.035055)*x1244))+(((0.035055)*x1242))+(((-0.4184)*x1250))+((r00*x1257)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j2, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1258=((1.0)*cj0);
IkReal x1259=((1.0)*sj0);
IkReal x1260=(cj4*cj5);
IkReal x1261=((1.0)*cj4*sj5);
CheckValue<IkReal> x1262=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r22))+((cj5*r20*sj4))+(((-1.0)*(1.0)*r21*sj4*sj5)))),-1);
if(!x1262.valid){
continue;
}
CheckValue<IkReal> x1263 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r11*x1259))+(((-1.0)*cj5*r01*x1258))+(((-1.0)*r10*sj5*x1259))+(((-1.0)*r00*sj5*x1258)))),IkReal(((((-1.0)*r11*sj0*x1261))+((cj0*r00*x1260))+((cj0*r02*sj4))+((r10*sj0*x1260))+((r12*sj0*sj4))+(((-1.0)*cj0*r01*x1261)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1263.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1262.value)))+(x1263.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1264=IKcos(j3);
IkReal x1265=((1.0)*cj5*x1264);
IkReal x1266=((1.0)*sj5*x1264);
IkReal x1267=IKsin(j3);
IkReal x1268=((1.0)*sj4*x1267);
IkReal x1269=(cj4*sj5*x1267);
IkReal x1270=((1.0)*cj4*cj5*x1267);
evalcond[0]=((((-1.0)*r22*x1268))+(((-1.0)*r20*x1266))+((r21*x1269))+(((-1.0)*r20*x1270))+(((-1.0)*r21*x1265)));
evalcond[1]=((((-1.0)*r00*x1270))+(((-1.0)*r01*x1265))+sj0+(((-1.0)*r00*x1266))+((r01*x1269))+(((-1.0)*r02*x1268)));
evalcond[2]=((((-1.0)*r10*x1270))+((r11*x1269))+(((-1.0)*r10*x1266))+(((-1.0)*(1.0)*cj0))+(((-1.0)*r12*x1268))+(((-1.0)*r11*x1265)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1271=((1.76)*sj0);
IkReal x1272=((-1.0)*x1271);
IkReal x1273=(cj4*r12);
IkReal x1274=(pz*sj0);
IkReal x1275=(cj4*r22*sj0);
IkReal x1276=(cj5*r10*sj4);
IkReal x1277=(cj5*r21*sj0);
IkReal x1278=(r11*sj4*sj5);
IkReal x1279=(r20*sj0*sj5);
IkReal x1280=(cj5*r20*sj0*sj4);
IkReal x1281=(r21*sj0*sj4*sj5);
IkReal x1282=((((-5.0208)*x1280))+(((-12.0)*x1274))+(((5.0208)*x1275))+(((-0.42066)*x1276))+(((0.42066)*x1278))+(((0.039)*x1279))+(((0.42066)*x1273))+(((0.039)*x1277))+(((5.0208)*x1281)));
IkReal x1283=((1.76)*cj0);
IkReal x1284=((-1.0)*x1283);
IkReal x1285=(cj0*pz);
IkReal x1286=(cj4*r02);
IkReal x1287=(cj0*cj4*r22);
IkReal x1288=(cj0*cj5*r21);
IkReal x1289=(cj0*r20*sj5);
IkReal x1290=(cj5*r00*sj4);
IkReal x1291=(r01*sj4*sj5);
IkReal x1292=(cj0*cj5*r20*sj4);
IkReal x1293=(cj0*r21*sj4*sj5);
IkReal x1294=((((0.42066)*x1286))+(((0.039)*x1289))+(((0.42066)*x1291))+(((0.039)*x1288))+(((5.0208)*x1287))+(((-0.42066)*x1290))+(((5.0208)*x1293))+(((-12.0)*x1285))+(((-5.0208)*x1292)));
j1eval[0]=((IKabs((x1294+x1284)))+(IKabs((x1271+x1282)))+(IKabs(((((1.6736)*x1293))+(((-0.14022)*x1290))+(((0.013)*x1289))+(((0.013)*x1288))+(((1.6736)*x1287))+(((0.14022)*x1286))+(((-4.0)*x1285))+x1284+(((0.14022)*x1291))+(((-1.6736)*x1292)))))+(IKabs((x1272+x1282)))+(IKabs(((((0.013)*x1279))+(((0.14022)*x1278))+(((-4.0)*x1274))+(((0.013)*x1277))+(((-0.14022)*x1276))+(((-1.6736)*x1280))+(((1.6736)*x1275))+x1272+(((1.6736)*x1281))+(((0.14022)*x1273)))))+(IKabs((x1294+x1283))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1295=((1.76)*cj0);
IkReal x1296=((-1.0)*x1295);
IkReal x1297=(cj0*pz);
IkReal x1298=(cj4*r02);
IkReal x1299=(cj0*cj4*r22);
IkReal x1300=(cj0*cj5*r21);
IkReal x1301=(cj0*r20*sj5);
IkReal x1302=(cj5*r00*sj4);
IkReal x1303=(r01*sj4*sj5);
IkReal x1304=(cj0*cj5*r20*sj4);
IkReal x1305=(cj0*r21*sj4*sj5);
IkReal x1306=((((-1.6736)*x1304))+(((-0.14022)*x1302))+(((-4.0)*x1297))+(((1.6736)*x1305))+(((1.6736)*x1299))+(((0.14022)*x1298))+(((0.013)*x1300))+(((0.013)*x1301))+(((0.14022)*x1303)));
IkReal x1307=((((5.0208)*x1305))+(((-0.42066)*x1302))+(((0.42066)*x1303))+(((-5.0208)*x1304))+(((-12.0)*x1297))+(((0.42066)*x1298))+(((0.039)*x1300))+(((5.0208)*x1299))+(((0.039)*x1301)));
op[0]=(x1306+x1296);
op[1]=0;
op[2]=(x1307+x1296);
op[3]=0;
op[4]=(x1307+x1295);
op[5]=0;
op[6]=(x1306+x1295);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1308=(cj4*r12);
IkReal x1309=(pz*sj0);
IkReal x1310=(cj4*r22*sj0);
IkReal x1311=(cj5*r10*sj4);
IkReal x1312=(cj5*r21*sj0);
IkReal x1313=(r11*sj4*sj5);
IkReal x1314=(r20*sj0*sj5);
IkReal x1315=(cj5*r20*sj0*sj4);
IkReal x1316=(r21*sj0*sj4*sj5);
IkReal x1317=((((1.6736)*x1310))+(((0.14022)*x1308))+(((0.013)*x1312))+(((-0.14022)*x1311))+(((0.14022)*x1313))+(((0.013)*x1314))+(((-1.6736)*x1315))+(((1.6736)*x1316))+(((-4.0)*x1309)));
IkReal x1318=((1.76)*sj0);
IkReal x1319=((((0.42066)*x1308))+(((0.039)*x1314))+(((-0.42066)*x1311))+(((5.0208)*x1310))+(((-12.0)*x1309))+(((0.42066)*x1313))+(((0.039)*x1312))+(((-5.0208)*x1315))+(((5.0208)*x1316)));
IkReal x1320=((-1.0)*x1318);
j1evalpoly[0]=((((htj1*htj1*htj1*htj1*htj1*htj1)*((x1320+x1317))))+(((htj1*htj1)*((x1319+x1318))))+(((htj1*htj1*htj1*htj1)*((x1320+x1319))))+x1318+x1317);
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1321=(cj4*r22);
IkReal x1322=(cj1*sj4);
IkReal x1323=(cj3*r22);
IkReal x1324=(sj1*sj4);
IkReal x1325=(cj5*r20);
IkReal x1326=(cj5*r21);
IkReal x1327=((1.0)*sj1*sj3);
IkReal x1328=(r20*sj5);
IkReal x1329=(cj3*cj4*cj5*r20);
IkReal x1330=(cj3*cj4);
IkReal x1331=((1.0)*r21*sj1*sj5);
IkReal x1332=((1.0)*cj1*sj3);
if( IKabs(((((-1.0)*x1326*x1327))+((sj1*x1329))+(((-1.0)*cj1*sj4*x1325))+((x1323*x1324))+(((-1.0)*x1327*x1328))+((cj1*x1321))+((r21*sj5*x1322))+(((-1.0)*x1330*x1331)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x1321))+((cj1*x1329))+(((-1.0)*x1326*x1332))+(((-1.0)*cj1*r21*sj5*x1330))+((x1324*x1325))+(((-1.0)*sj4*x1331))+(((-1.0)*x1328*x1332))+((x1322*x1323)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1326*x1327))+((sj1*x1329))+(((-1.0)*cj1*sj4*x1325))+((x1323*x1324))+(((-1.0)*x1327*x1328))+((cj1*x1321))+((r21*sj5*x1322))+(((-1.0)*x1330*x1331))))+IKsqr(((((-1.0)*sj1*x1321))+((cj1*x1329))+(((-1.0)*x1326*x1332))+(((-1.0)*cj1*r21*sj5*x1330))+((x1324*x1325))+(((-1.0)*sj4*x1331))+(((-1.0)*x1328*x1332))+((x1322*x1323))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1326*x1327))+((sj1*x1329))+(((-1.0)*cj1*sj4*x1325))+((x1323*x1324))+(((-1.0)*x1327*x1328))+((cj1*x1321))+((r21*sj5*x1322))+(((-1.0)*x1330*x1331))), ((((-1.0)*sj1*x1321))+((cj1*x1329))+(((-1.0)*x1326*x1332))+(((-1.0)*cj1*r21*sj5*x1330))+((x1324*x1325))+(((-1.0)*sj4*x1331))+(((-1.0)*x1328*x1332))+((x1322*x1323))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1333=IKsin(j2);
IkReal x1334=(cj1*x1333);
IkReal x1335=((1.0)*cj4);
IkReal x1336=(cj5*sj4);
IkReal x1337=IKcos(j2);
IkReal x1338=(sj1*x1337);
IkReal x1339=((1.0)*sj4*sj5);
IkReal x1340=(cj1*x1337);
IkReal x1341=(cj0*x1340);
IkReal x1342=(sj1*x1333);
IkReal x1343=(cj0*x1342);
IkReal x1344=(sj0*x1340);
IkReal x1345=(sj0*x1342);
IkReal x1346=(cj5*sj3);
IkReal x1347=(sj3*sj5);
IkReal x1348=((1.0)*cj3*sj4);
IkReal x1349=(cj3*cj4*sj5);
IkReal x1350=((1.0)*cj3*cj4*cj5);
IkReal x1351=((0.00325)*cj5);
IkReal x1352=((0.00325)*sj5);
IkReal x1353=(cj0*x1338);
IkReal x1354=(cj0*cj1*x1333);
IkReal x1355=(sj0*x1338);
IkReal x1356=(cj1*sj0*x1333);
IkReal x1357=((0.44)*sj1);
evalcond[0]=((((-1.0)*r21*x1339))+(((-1.0)*x1338))+((r20*x1336))+x1334+(((-1.0)*r22*x1335)));
evalcond[1]=((((-1.0)*r01*x1339))+((r00*x1336))+(((-1.0)*r02*x1335))+x1343+x1341);
evalcond[2]=(((r10*x1336))+(((-1.0)*r12*x1335))+(((-1.0)*r11*x1339))+x1344+x1345);
evalcond[3]=((((-1.0)*r20*x1350))+(((-1.0)*r22*x1348))+((r21*x1349))+((r20*x1347))+((r21*x1346))+x1342+x1340);
evalcond[4]=((((0.4184)*x1334))+(((0.035055)*x1342))+((r21*x1351))+((r20*x1352))+(((-1.0)*(1.0)*pz))+(((-0.4184)*x1338))+(((0.44)*cj1))+(((0.035055)*x1340)));
evalcond[5]=(((r01*x1346))+(((-1.0)*r00*x1350))+(((-1.0)*x1354))+((r00*x1347))+x1353+((r01*x1349))+(((-1.0)*r02*x1348)));
evalcond[6]=(((r10*x1347))+(((-1.0)*r10*x1350))+((r11*x1349))+(((-1.0)*x1356))+x1355+((r11*x1346))+(((-1.0)*r12*x1348)));
evalcond[7]=((((-1.0)*(1.0)*px))+((cj0*x1357))+(((-1.0)*(0.0054374)*sj0))+(((0.05)*cj0))+(((0.4184)*x1343))+((r01*x1351))+(((0.4184)*x1341))+(((0.035055)*x1353))+(((-0.035055)*x1354))+((r00*x1352)));
evalcond[8]=((((0.4184)*x1345))+(((-1.0)*(1.0)*py))+((r10*x1352))+(((0.05)*sj0))+(((0.035055)*x1355))+(((-0.035055)*x1356))+(((0.4184)*x1344))+((r11*x1351))+(((0.0054374)*cj0))+((sj0*x1357)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1358=((1.0)*cj0*r21);
CheckValue<IkReal> x1359=IKPowWithIntegerCheck(IKsign((((r01*sj4*sj5))+((cj4*r02))+(((-1.0)*(1.0)*cj5*r00*sj4)))),-1);
if(!x1359.valid){
continue;
}
CheckValue<IkReal> x1360 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*x1358))+(((-1.0)*cj0*r20*sj5)))),IkReal((((cj0*cj4*cj5*r20))+((cj0*r22*sj4))+(((-1.0)*cj4*sj5*x1358)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1360.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1359.value)))+(x1360.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1361=IKcos(j3);
IkReal x1362=((1.0)*cj5*x1361);
IkReal x1363=((1.0)*sj5*x1361);
IkReal x1364=IKsin(j3);
IkReal x1365=((1.0)*sj4*x1364);
IkReal x1366=(cj4*sj5*x1364);
IkReal x1367=((1.0)*cj4*cj5*x1364);
evalcond[0]=((((-1.0)*r22*x1365))+(((-1.0)*r21*x1362))+(((-1.0)*r20*x1363))+((r21*x1366))+(((-1.0)*r20*x1367)));
evalcond[1]=((((-1.0)*r00*x1363))+(((-1.0)*r01*x1362))+(((-1.0)*r00*x1367))+sj0+((r01*x1366))+(((-1.0)*r02*x1365)));
evalcond[2]=((((-1.0)*r11*x1362))+(((-1.0)*r10*x1363))+(((-1.0)*r10*x1367))+(((-1.0)*(1.0)*cj0))+(((-1.0)*r12*x1365))+((r11*x1366)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1368=((1.76)*sj0);
IkReal x1369=((-1.0)*x1368);
IkReal x1370=(cj4*r12);
IkReal x1371=(pz*sj0);
IkReal x1372=(cj4*r22*sj0);
IkReal x1373=(cj5*r10*sj4);
IkReal x1374=(cj5*r21*sj0);
IkReal x1375=(r11*sj4*sj5);
IkReal x1376=(r20*sj0*sj5);
IkReal x1377=(cj5*r20*sj0*sj4);
IkReal x1378=(r21*sj0*sj4*sj5);
IkReal x1379=((((-5.0208)*x1377))+(((-0.42066)*x1373))+(((5.0208)*x1378))+(((0.039)*x1376))+(((0.42066)*x1375))+(((5.0208)*x1372))+(((0.42066)*x1370))+(((0.039)*x1374))+(((-12.0)*x1371)));
IkReal x1380=((1.76)*cj0);
IkReal x1381=((-1.0)*x1380);
IkReal x1382=(cj0*pz);
IkReal x1383=(cj4*r02);
IkReal x1384=(cj0*cj4*r22);
IkReal x1385=(cj0*cj5*r21);
IkReal x1386=(cj0*r20*sj5);
IkReal x1387=(cj5*r00*sj4);
IkReal x1388=(r01*sj4*sj5);
IkReal x1389=(cj0*cj5*r20*sj4);
IkReal x1390=(cj0*r21*sj4*sj5);
IkReal x1391=((((5.0208)*x1390))+(((-12.0)*x1382))+(((-0.42066)*x1387))+(((0.42066)*x1383))+(((-5.0208)*x1389))+(((0.039)*x1386))+(((0.42066)*x1388))+(((5.0208)*x1384))+(((0.039)*x1385)));
j1eval[0]=((IKabs(((((1.6736)*x1372))+(((0.013)*x1376))+(((-1.6736)*x1377))+(((-4.0)*x1371))+(((0.14022)*x1370))+(((0.14022)*x1375))+(((0.013)*x1374))+(((-0.14022)*x1373))+x1369+(((1.6736)*x1378)))))+(IKabs((x1379+x1369)))+(IKabs((x1380+x1391)))+(IKabs((x1379+x1368)))+(IKabs(((((-1.6736)*x1389))+(((0.14022)*x1383))+(((0.013)*x1385))+(((0.013)*x1386))+(((1.6736)*x1390))+(((-0.14022)*x1387))+x1381+(((-4.0)*x1382))+(((1.6736)*x1384))+(((0.14022)*x1388)))))+(IKabs((x1381+x1391))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1392=((1.76)*cj0);
IkReal x1393=((-1.0)*x1392);
IkReal x1394=(cj0*pz);
IkReal x1395=(cj4*r02);
IkReal x1396=(cj0*cj4*r22);
IkReal x1397=(cj0*cj5*r21);
IkReal x1398=(cj0*r20*sj5);
IkReal x1399=(cj5*r00*sj4);
IkReal x1400=(r01*sj4*sj5);
IkReal x1401=(cj0*cj5*r20*sj4);
IkReal x1402=(cj0*r21*sj4*sj5);
IkReal x1403=((((1.6736)*x1396))+(((1.6736)*x1402))+(((0.013)*x1397))+(((-4.0)*x1394))+(((0.013)*x1398))+(((-1.6736)*x1401))+(((0.14022)*x1395))+(((-0.14022)*x1399))+(((0.14022)*x1400)));
IkReal x1404=((((0.039)*x1398))+(((0.039)*x1397))+(((-0.42066)*x1399))+(((5.0208)*x1396))+(((0.42066)*x1395))+(((0.42066)*x1400))+(((-5.0208)*x1401))+(((5.0208)*x1402))+(((-12.0)*x1394)));
op[0]=(x1403+x1393);
op[1]=0;
op[2]=(x1404+x1393);
op[3]=0;
op[4]=(x1404+x1392);
op[5]=0;
op[6]=(x1403+x1392);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1405=(cj4*r12);
IkReal x1406=(pz*sj0);
IkReal x1407=(cj4*r22*sj0);
IkReal x1408=(cj5*r10*sj4);
IkReal x1409=(cj5*r21*sj0);
IkReal x1410=(r11*sj4*sj5);
IkReal x1411=(r20*sj0*sj5);
IkReal x1412=(cj5*r20*sj0*sj4);
IkReal x1413=(r21*sj0*sj4*sj5);
IkReal x1414=((((-0.14022)*x1408))+(((-1.6736)*x1412))+(((1.6736)*x1407))+(((0.14022)*x1405))+(((0.013)*x1411))+(((-4.0)*x1406))+(((1.6736)*x1413))+(((0.013)*x1409))+(((0.14022)*x1410)));
IkReal x1415=((1.76)*sj0);
IkReal x1416=((((5.0208)*x1407))+(((5.0208)*x1413))+(((0.42066)*x1410))+(((-0.42066)*x1408))+(((0.039)*x1411))+(((-12.0)*x1406))+(((-5.0208)*x1412))+(((0.42066)*x1405))+(((0.039)*x1409)));
IkReal x1417=((-1.0)*x1415);
j1evalpoly[0]=(x1414+x1415+(((htj1*htj1*htj1*htj1)*((x1417+x1416))))+(((htj1*htj1)*((x1415+x1416))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x1414+x1417)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1418=(cj4*r22);
IkReal x1419=(cj1*sj4);
IkReal x1420=(cj3*r22);
IkReal x1421=(sj1*sj4);
IkReal x1422=(cj5*r20);
IkReal x1423=(cj5*r21);
IkReal x1424=((1.0)*sj1*sj3);
IkReal x1425=(r20*sj5);
IkReal x1426=(cj3*cj4*cj5*r20);
IkReal x1427=(cj3*cj4);
IkReal x1428=((1.0)*r21*sj1*sj5);
IkReal x1429=((1.0)*cj1*sj3);
if( IKabs((((x1420*x1421))+(((-1.0)*x1423*x1424))+(((-1.0)*x1424*x1425))+(((-1.0)*x1427*x1428))+((r21*sj5*x1419))+((sj1*x1426))+(((-1.0)*cj1*sj4*x1422))+((cj1*x1418)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*r21*sj5*x1427))+((x1419*x1420))+((x1421*x1422))+((cj1*x1426))+(((-1.0)*sj4*x1428))+(((-1.0)*sj1*x1418))+(((-1.0)*x1423*x1429))+(((-1.0)*x1425*x1429)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1420*x1421))+(((-1.0)*x1423*x1424))+(((-1.0)*x1424*x1425))+(((-1.0)*x1427*x1428))+((r21*sj5*x1419))+((sj1*x1426))+(((-1.0)*cj1*sj4*x1422))+((cj1*x1418))))+IKsqr(((((-1.0)*cj1*r21*sj5*x1427))+((x1419*x1420))+((x1421*x1422))+((cj1*x1426))+(((-1.0)*sj4*x1428))+(((-1.0)*sj1*x1418))+(((-1.0)*x1423*x1429))+(((-1.0)*x1425*x1429))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x1420*x1421))+(((-1.0)*x1423*x1424))+(((-1.0)*x1424*x1425))+(((-1.0)*x1427*x1428))+((r21*sj5*x1419))+((sj1*x1426))+(((-1.0)*cj1*sj4*x1422))+((cj1*x1418))), ((((-1.0)*cj1*r21*sj5*x1427))+((x1419*x1420))+((x1421*x1422))+((cj1*x1426))+(((-1.0)*sj4*x1428))+(((-1.0)*sj1*x1418))+(((-1.0)*x1423*x1429))+(((-1.0)*x1425*x1429))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1430=IKsin(j2);
IkReal x1431=(cj1*x1430);
IkReal x1432=((1.0)*cj4);
IkReal x1433=(cj5*sj4);
IkReal x1434=IKcos(j2);
IkReal x1435=(sj1*x1434);
IkReal x1436=((1.0)*sj4*sj5);
IkReal x1437=(cj1*x1434);
IkReal x1438=(cj0*x1437);
IkReal x1439=(sj1*x1430);
IkReal x1440=(cj0*x1439);
IkReal x1441=(sj0*x1437);
IkReal x1442=(sj0*x1439);
IkReal x1443=(cj5*sj3);
IkReal x1444=(sj3*sj5);
IkReal x1445=((1.0)*cj3*sj4);
IkReal x1446=(cj3*cj4*sj5);
IkReal x1447=((1.0)*cj3*cj4*cj5);
IkReal x1448=((0.00325)*cj5);
IkReal x1449=((0.00325)*sj5);
IkReal x1450=(cj0*x1435);
IkReal x1451=(cj0*cj1*x1430);
IkReal x1452=(sj0*x1435);
IkReal x1453=(cj1*sj0*x1430);
IkReal x1454=((0.44)*sj1);
evalcond[0]=((((-1.0)*r21*x1436))+((r20*x1433))+x1431+(((-1.0)*r22*x1432))+(((-1.0)*x1435)));
evalcond[1]=((((-1.0)*r02*x1432))+x1438+((r00*x1433))+x1440+(((-1.0)*r01*x1436)));
evalcond[2]=((((-1.0)*r11*x1436))+((r10*x1433))+(((-1.0)*r12*x1432))+x1441+x1442);
evalcond[3]=(((r21*x1446))+(((-1.0)*r22*x1445))+(((-1.0)*r20*x1447))+x1437+x1439+((r20*x1444))+((r21*x1443)));
evalcond[4]=((((-1.0)*(1.0)*pz))+(((0.44)*cj1))+((r21*x1448))+(((0.4184)*x1431))+(((0.035055)*x1439))+(((0.035055)*x1437))+(((-0.4184)*x1435))+((r20*x1449)));
evalcond[5]=((((-1.0)*x1451))+((r01*x1446))+((r01*x1443))+(((-1.0)*r00*x1447))+((r00*x1444))+x1450+(((-1.0)*r02*x1445)));
evalcond[6]=((((-1.0)*r12*x1445))+((r11*x1446))+(((-1.0)*x1453))+((r10*x1444))+(((-1.0)*r10*x1447))+x1452+((r11*x1443)));
evalcond[7]=(((cj0*x1454))+(((-1.0)*(1.0)*px))+(((0.035055)*x1450))+((r00*x1449))+(((-1.0)*(0.0054374)*sj0))+(((0.05)*cj0))+(((-0.035055)*x1451))+(((0.4184)*x1438))+((r01*x1448))+(((0.4184)*x1440)));
evalcond[8]=((((0.035055)*x1452))+(((-1.0)*(1.0)*py))+(((0.05)*sj0))+((sj0*x1454))+(((-0.035055)*x1453))+(((0.0054374)*cj0))+(((0.4184)*x1442))+((r11*x1448))+((r10*x1449))+(((0.4184)*x1441)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1455=((1.0)*sj4);
IkReal x1456=(r21*sj0);
IkReal x1457=(r20*sj0);
CheckValue<IkReal> x1458=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r12))+((cj5*r10*sj4))+(((-1.0)*r11*sj5*x1455)))),-1);
if(!x1458.valid){
continue;
}
CheckValue<IkReal> x1459 = IKatan2WithCheck(IkReal((((cj5*x1456))+((sj5*x1457)))),IkReal((((cj4*sj5*x1456))+(((-1.0)*r22*sj0*x1455))+(((-1.0)*cj4*cj5*x1457)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1459.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1458.value)))+(x1459.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1460=IKcos(j3);
IkReal x1461=((1.0)*cj5*x1460);
IkReal x1462=((1.0)*sj5*x1460);
IkReal x1463=IKsin(j3);
IkReal x1464=((1.0)*sj4*x1463);
IkReal x1465=(cj4*sj5*x1463);
IkReal x1466=((1.0)*cj4*cj5*x1463);
evalcond[0]=(((r21*x1465))+(((-1.0)*r21*x1461))+(((-1.0)*r20*x1466))+(((-1.0)*r20*x1462))+(((-1.0)*r22*x1464)));
evalcond[1]=((((-1.0)*r00*x1462))+(((-1.0)*r02*x1464))+(((-1.0)*r01*x1461))+(((-1.0)*r00*x1466))+sj0+((r01*x1465)));
evalcond[2]=((((-1.0)*r10*x1462))+((r11*x1465))+(((-1.0)*r12*x1464))+(((-1.0)*r10*x1466))+(((-1.0)*r11*x1461))+(((-1.0)*(1.0)*cj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1467=((1.76)*sj0);
IkReal x1468=((-1.0)*x1467);
IkReal x1469=(cj4*r12);
IkReal x1470=(pz*sj0);
IkReal x1471=(cj4*r22*sj0);
IkReal x1472=(cj5*r10*sj4);
IkReal x1473=(cj5*r21*sj0);
IkReal x1474=(r11*sj4*sj5);
IkReal x1475=(r20*sj0*sj5);
IkReal x1476=(cj5*r20*sj0*sj4);
IkReal x1477=(r21*sj0*sj4*sj5);
IkReal x1478=((((-0.42066)*x1472))+(((0.039)*x1475))+(((0.039)*x1473))+(((5.0208)*x1471))+(((5.0208)*x1477))+(((0.42066)*x1474))+(((-12.0)*x1470))+(((0.42066)*x1469))+(((-5.0208)*x1476)));
IkReal x1479=((1.76)*cj0);
IkReal x1480=((-1.0)*x1479);
IkReal x1481=(cj0*pz);
IkReal x1482=(cj4*r02);
IkReal x1483=(cj0*cj4*r22);
IkReal x1484=(cj0*cj5*r21);
IkReal x1485=(cj0*r20*sj5);
IkReal x1486=(cj5*r00*sj4);
IkReal x1487=(r01*sj4*sj5);
IkReal x1488=(cj0*cj5*r20*sj4);
IkReal x1489=(cj0*r21*sj4*sj5);
IkReal x1490=((((0.42066)*x1487))+(((5.0208)*x1483))+(((-12.0)*x1481))+(((0.039)*x1484))+(((5.0208)*x1489))+(((-5.0208)*x1488))+(((0.039)*x1485))+(((0.42066)*x1482))+(((-0.42066)*x1486)));
j1eval[0]=((IKabs((x1490+x1479)))+(IKabs((x1468+x1478)))+(IKabs((x1467+x1478)))+(IKabs((x1490+x1480)))+(IKabs(((((0.013)*x1484))+(((0.14022)*x1482))+(((1.6736)*x1489))+(((0.14022)*x1487))+(((0.013)*x1485))+(((-4.0)*x1481))+(((-0.14022)*x1486))+(((1.6736)*x1483))+x1480+(((-1.6736)*x1488)))))+(IKabs(((((0.013)*x1475))+(((1.6736)*x1471))+(((1.6736)*x1477))+(((0.14022)*x1474))+(((0.013)*x1473))+(((0.14022)*x1469))+(((-0.14022)*x1472))+x1468+(((-1.6736)*x1476))+(((-4.0)*x1470))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1491=((1.76)*cj0);
IkReal x1492=((-1.0)*x1491);
IkReal x1493=(cj0*pz);
IkReal x1494=(cj4*r02);
IkReal x1495=(cj0*cj4*r22);
IkReal x1496=(cj0*cj5*r21);
IkReal x1497=(cj0*r20*sj5);
IkReal x1498=(cj5*r00*sj4);
IkReal x1499=(r01*sj4*sj5);
IkReal x1500=(cj0*cj5*r20*sj4);
IkReal x1501=(cj0*r21*sj4*sj5);
IkReal x1502=((((0.013)*x1496))+(((0.14022)*x1494))+(((1.6736)*x1495))+(((-0.14022)*x1498))+(((0.013)*x1497))+(((0.14022)*x1499))+(((-1.6736)*x1500))+(((1.6736)*x1501))+(((-4.0)*x1493)));
IkReal x1503=((((-5.0208)*x1500))+(((0.039)*x1496))+(((0.039)*x1497))+(((5.0208)*x1495))+(((0.42066)*x1499))+(((0.42066)*x1494))+(((-0.42066)*x1498))+(((5.0208)*x1501))+(((-12.0)*x1493)));
op[0]=(x1492+x1502);
op[1]=0;
op[2]=(x1492+x1503);
op[3]=0;
op[4]=(x1491+x1503);
op[5]=0;
op[6]=(x1491+x1502);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1504=(cj4*r12);
IkReal x1505=(pz*sj0);
IkReal x1506=(cj4*r22*sj0);
IkReal x1507=(cj5*r10*sj4);
IkReal x1508=(cj5*r21*sj0);
IkReal x1509=(r11*sj4*sj5);
IkReal x1510=(r20*sj0*sj5);
IkReal x1511=(cj5*r20*sj0*sj4);
IkReal x1512=(r21*sj0*sj4*sj5);
IkReal x1513=((((0.14022)*x1509))+(((-4.0)*x1505))+(((-0.14022)*x1507))+(((-1.6736)*x1511))+(((1.6736)*x1512))+(((0.013)*x1510))+(((0.013)*x1508))+(((0.14022)*x1504))+(((1.6736)*x1506)));
IkReal x1514=((1.76)*sj0);
IkReal x1515=((((0.42066)*x1509))+(((-5.0208)*x1511))+(((0.039)*x1510))+(((0.039)*x1508))+(((5.0208)*x1512))+(((-12.0)*x1505))+(((5.0208)*x1506))+(((0.42066)*x1504))+(((-0.42066)*x1507)));
IkReal x1516=((-1.0)*x1514);
j1evalpoly[0]=(x1514+x1513+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x1513+x1516))))+(((htj1*htj1*htj1*htj1)*((x1515+x1516))))+(((htj1*htj1)*((x1514+x1515)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1517=(cj4*r22);
IkReal x1518=(cj1*sj4);
IkReal x1519=(cj3*r22);
IkReal x1520=(sj1*sj4);
IkReal x1521=(cj5*r20);
IkReal x1522=(cj5*r21);
IkReal x1523=((1.0)*sj1*sj3);
IkReal x1524=(r20*sj5);
IkReal x1525=(cj3*cj4*cj5*r20);
IkReal x1526=(cj3*cj4);
IkReal x1527=((1.0)*r21*sj1*sj5);
IkReal x1528=((1.0)*cj1*sj3);
if( IKabs(((((-1.0)*cj1*sj4*x1521))+(((-1.0)*x1523*x1524))+((x1519*x1520))+(((-1.0)*x1522*x1523))+(((-1.0)*x1526*x1527))+((sj1*x1525))+((r21*sj5*x1518))+((cj1*x1517)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x1525))+(((-1.0)*sj4*x1527))+(((-1.0)*x1522*x1528))+((x1520*x1521))+(((-1.0)*x1524*x1528))+(((-1.0)*cj1*r21*sj5*x1526))+(((-1.0)*sj1*x1517))+((x1518*x1519)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*sj4*x1521))+(((-1.0)*x1523*x1524))+((x1519*x1520))+(((-1.0)*x1522*x1523))+(((-1.0)*x1526*x1527))+((sj1*x1525))+((r21*sj5*x1518))+((cj1*x1517))))+IKsqr((((cj1*x1525))+(((-1.0)*sj4*x1527))+(((-1.0)*x1522*x1528))+((x1520*x1521))+(((-1.0)*x1524*x1528))+(((-1.0)*cj1*r21*sj5*x1526))+(((-1.0)*sj1*x1517))+((x1518*x1519))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj1*sj4*x1521))+(((-1.0)*x1523*x1524))+((x1519*x1520))+(((-1.0)*x1522*x1523))+(((-1.0)*x1526*x1527))+((sj1*x1525))+((r21*sj5*x1518))+((cj1*x1517))), (((cj1*x1525))+(((-1.0)*sj4*x1527))+(((-1.0)*x1522*x1528))+((x1520*x1521))+(((-1.0)*x1524*x1528))+(((-1.0)*cj1*r21*sj5*x1526))+(((-1.0)*sj1*x1517))+((x1518*x1519))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1529=IKsin(j2);
IkReal x1530=(cj1*x1529);
IkReal x1531=((1.0)*cj4);
IkReal x1532=(cj5*sj4);
IkReal x1533=IKcos(j2);
IkReal x1534=(sj1*x1533);
IkReal x1535=((1.0)*sj4*sj5);
IkReal x1536=(cj1*x1533);
IkReal x1537=(cj0*x1536);
IkReal x1538=(sj1*x1529);
IkReal x1539=(cj0*x1538);
IkReal x1540=(sj0*x1536);
IkReal x1541=(sj0*x1538);
IkReal x1542=(cj5*sj3);
IkReal x1543=(sj3*sj5);
IkReal x1544=((1.0)*cj3*sj4);
IkReal x1545=(cj3*cj4*sj5);
IkReal x1546=((1.0)*cj3*cj4*cj5);
IkReal x1547=((0.00325)*cj5);
IkReal x1548=((0.00325)*sj5);
IkReal x1549=(cj0*x1534);
IkReal x1550=(cj0*cj1*x1529);
IkReal x1551=(sj0*x1534);
IkReal x1552=(cj1*sj0*x1529);
IkReal x1553=((0.44)*sj1);
evalcond[0]=((((-1.0)*x1534))+(((-1.0)*r21*x1535))+(((-1.0)*r22*x1531))+x1530+((r20*x1532)));
evalcond[1]=((((-1.0)*r02*x1531))+(((-1.0)*r01*x1535))+x1539+x1537+((r00*x1532)));
evalcond[2]=((((-1.0)*r12*x1531))+x1540+x1541+((r10*x1532))+(((-1.0)*r11*x1535)));
evalcond[3]=(((r21*x1545))+x1538+x1536+(((-1.0)*r20*x1546))+((r21*x1542))+((r20*x1543))+(((-1.0)*r22*x1544)));
evalcond[4]=((((-1.0)*(1.0)*pz))+(((0.4184)*x1530))+((r20*x1548))+(((0.44)*cj1))+(((0.035055)*x1536))+(((0.035055)*x1538))+((r21*x1547))+(((-0.4184)*x1534)));
evalcond[5]=((((-1.0)*r02*x1544))+(((-1.0)*x1550))+x1549+(((-1.0)*r00*x1546))+((r00*x1543))+((r01*x1542))+((r01*x1545)));
evalcond[6]=((((-1.0)*r12*x1544))+((r11*x1542))+((r11*x1545))+((r10*x1543))+x1551+(((-1.0)*r10*x1546))+(((-1.0)*x1552)));
evalcond[7]=((((-1.0)*(1.0)*px))+((r01*x1547))+((cj0*x1553))+(((-1.0)*(0.0054374)*sj0))+(((0.05)*cj0))+((r00*x1548))+(((0.4184)*x1537))+(((0.4184)*x1539))+(((-0.035055)*x1550))+(((0.035055)*x1549)));
evalcond[8]=((((0.4184)*x1541))+(((-1.0)*(1.0)*py))+((r10*x1548))+(((-0.035055)*x1552))+(((0.05)*sj0))+(((0.035055)*x1551))+((r11*x1547))+((sj0*x1553))+(((0.4184)*x1540))+(((0.0054374)*cj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - flippy (e6cc6688425818794294e64070713cef)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
